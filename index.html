<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hubohan.space","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
<meta property="og:type" content="website">
<meta property="og:title" content="Hu&#39;s Blog">
<meta property="og:url" content="http://hubohan.space/index.html">
<meta property="og:site_name" content="Hu&#39;s Blog">
<meta property="og:description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="胡博涵">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hubohan.space/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hu's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hu's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Who's blog?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">胡博涵</p>
  <div class="site-description" itemprop="description">CS Undergraduate at Harbin Institute of Technology, Shenzhen</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Bohan-Hu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Bohan-Hu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hubohancser@gmail.com" title="E-Mail → mailto:hubohancser@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content index posts-expand">
          
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/31/Difftest_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/Difftest_note/" class="post-title-link" itemprop="url">Nutshell仿真机制解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-31T00:00:00+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>近期接触了国科大的Nutshell项目，深感其差分测试思想的精妙之处，非常感谢国科大的教学团队为CPU测试提供了一个创新的思路。</p>
<p>本文记录了笔者学习差分测试源代码时的一些收获与想法。</p>
<p>要理解差分测试的源代码，首先需要理解Verilator仿真器的仿真机制。笔者在学习Verilator的过程中，也记录了相关的笔记：<a href="https://hubohan.space/2020/08/30/Verilator_note/">https://hubohan.space/2020/08/30/Verilator_note/</a></p>
<h3 id="差分测试的总体思想"><a href="#差分测试的总体思想" class="headerlink" title="差分测试的总体思想"></a>差分测试的总体思想</h3><p>在参加“龙芯杯”竞赛的时候，我们接触了基于<code>trace</code>比对的测试机制，让DUT和黄金模型同样执行一段程序，捕捉黄金模型处理器状态改变的轨迹，即哪条指令(PC)在何时(trace中的顺序)往哪个寄存器(<code>wnum</code>)写入了什么值(<code>wbdata</code>)，然后将DUT执行的轨迹和黄金模型执行的轨迹逐条比对，遇到出错点即停止执行，这其中其实也用到了差分测试的思路。</p>
<p>Easydiff是Nutshell采用的测试框架，它将这个差分测试的思想更进了一步，<code>trace</code>比对机制是将处理器状态改变的<strong>轨迹</strong>进行比对，而Easydiff是将处理器的<strong>全状态</strong>进行比对，包括GPR、控制寄存器和PC。毫无疑问地，这个比对的粒度更细，能够更精确地定位到错误点。</p>
<p>在Easydiff中，DUT是我们自己实现的CPU，黄金模型是南京大学的NEMU模拟器。Easydiff在DUT状态改变的时候，立即让NEMU模拟器执行和DUT相同的指令，并且比对其状态，若有差异，立刻报错停止。</p>
<p>在Easydiff框架中，采用的仿真器是Verilator，其将Verilog源码构建为C++描述的仿真模型，而C++语言相较Verilog，具有更大的灵活性。项目提供的NEMU模拟器为动态链接库的形式，能够在运行时灵活地调用其API，进行动态链接。</p>
<p>为了屏蔽NEMU的实现细节，将NEMU提供的API摘录如下：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ref_difftest_getregs</td>
<td>从NEMU中获取寄存器状态</td>
</tr>
<tr>
<td>ref_difftest_setregs</td>
<td>设置NEMU的寄存器状态</td>
</tr>
<tr>
<td>ref_difftest_exec</td>
<td>NEMU执行n条指令</td>
</tr>
<tr>
<td>ref_difftest_raise_intr</td>
<td>触发NEMU的中断</td>
</tr>
</tbody></table>
<p>在仿真阶段，NEMU的API通过动态链接的形式在仿真驱动代码<code>main.cpp</code>以及其下层函数中被调用，使用者无需关注其实现细节。</p>
<h3 id="观察生成的Verilog顶层模型"><a href="#观察生成的Verilog顶层模型" class="headerlink" title="观察生成的Verilog顶层模型"></a>观察生成的Verilog顶层模型</h3><ul>
<li><p>使用<code>make verilog</code>生成相应的Verilog文件，最终生成的代码在<code>build/Topmain.v</code>里面</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829214644319.png" alt="image-20200829214644319"></p>
</li>
</ul>
<p>其中可以看到，除了NutShell的顶层模块之外，还有<code>SDHelper.v</code>，<code>UARTGetc.v</code>和<code>FBHelper.v</code>三个文件，这三个文件是使用了Verilog与C语言的DPI接口，使用C语言描述相关的仿真行为，并在Verilog中进行调用，我们可以在文件中找到相关的细节：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;DPI-C&quot;</span> <span class="keyword">function</span> <span class="keyword">void</span> uart_getc(<span class="keyword">output</span> <span class="keyword">byte</span> ch);</span><br></pre></td></tr></table></figure>

<p>为什么要这样写呢？因为仿真时可能会用到串口输入，而我们的控制台明显无法仿真串口，需要用C语言编写一个“假”的串口来进行仿真，而这个“串口”可以读取用户的键盘输入，并且将DUT的输出显示在控制台上。</p>
<p>关于DPI-C的接口使用，稍后会进行介绍。</p>
<p>同时注意到，仿真所使用的顶层模块<code>NutShellSimTop</code>，其暴露给外部有以下接口：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> NutShellSimTop(</span><br><span class="line">  <span class="keyword">input</span>         clock,</span><br><span class="line">  <span class="keyword">input</span>         reset,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_r0,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_r1,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_r2,</span><br><span class="line">  <span class="comment">// ...........................中间略 ............................</span></span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_r30,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_r31,</span><br><span class="line">  <span class="keyword">output</span>        io_difftest_commit,</span><br><span class="line">  <span class="keyword">output</span>        io_difftest_isMultiCommit,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_thisPC,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] io_difftest_thisINST,</span><br><span class="line">  <span class="keyword">output</span>        io_difftest_isMMIO,</span><br><span class="line">  <span class="keyword">output</span>        io_difftest_isRVC,</span><br><span class="line">  <span class="keyword">output</span>        io_difftest_isRVC2,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_intrNO,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">1</span>:<span class="number">0</span>]  io_difftest_priviledgeMode,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_mstatus,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_sstatus,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_mepc,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_sepc,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_mcause,</span><br><span class="line">  <span class="keyword">output</span> [<span class="number">63</span>:<span class="number">0</span>] io_difftest_scause,</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">63</span>:<span class="number">0</span>] io_logCtrl_log_begin,</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">63</span>:<span class="number">0</span>] io_logCtrl_log_end,</span><br><span class="line">  <span class="keyword">input</span>  [<span class="number">63</span>:<span class="number">0</span>] io_logCtrl_log_level,</span><br><span class="line">  <span class="keyword">output</span>        io_difftestCtrl_enable</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这些接口是暴露给编写的<code>difftest</code>函数使用的，目的在于进行对比。</p>
<h3 id="main-c-开始的地方"><a href="#main-c-开始的地方" class="headerlink" title="main.c - 开始的地方"></a><code>main.c</code> - 开始的地方</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> emu = Emulator(argc, argv);                    <span class="comment">// &lt;--------------- PAY ATTENTION TO IT</span></span><br><span class="line"></span><br><span class="line">  get_sc_time_stamp = [&amp;emu]() -&gt; <span class="keyword">double</span> &#123;            <span class="comment">// 匿名函数，lambda表达式</span></span><br><span class="line">    <span class="keyword">return</span> emu.get_cycles();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  emu.execute();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> <span class="title">uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> ms = uptime();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">display_trapinfo</span><span class="params">(<span class="keyword">uint64_t</span> max_cycles)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> ret = display_trapinfo(emu.get_max_cycles());</span><br><span class="line">  eprintf(ANSI_COLOR_BLUE <span class="string">&quot;Guest cycle spent: %&quot;</span> PRIu64 <span class="string">&quot;\n&quot;</span> ANSI_COLOR_RESET, emu.get_cycles());</span><br><span class="line">  eprintf(ANSI_COLOR_BLUE <span class="string">&quot;Host time spent: %dms\n&quot;</span> ANSI_COLOR_RESET, ms);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，主循环中，构造了一个模拟器<code>Emulator</code>，并且根据Verilator的要求，需要自行构造一个<code>get_cycle</code>的函数，以供Verilog中的<code>$time</code>任务调用。</p>
<p>那么需要熟悉的就是<code>Emulator</code>和里面的<code>execute</code>函数了。</p>
<h3 id="emu-h-解构Emulator类"><a href="#emu-h-解构Emulator类" class="headerlink" title="emu.h - 解构Emulator类"></a><code>emu.h</code> - 解构<code>Emulator</code>类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emulator</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *image;                            <span class="comment">// 镜像路径</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;VNutShellSimTop&gt; dut_ptr;     <span class="comment">// Verilator模型</span></span><br><span class="line">  VerilatedVcdC* tfp;                            <span class="comment">// Verilator波形（由宏定义进行开关）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仿真器控制的相关变量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> seed;</span><br><span class="line">  <span class="keyword">uint64_t</span> max_cycles, cycles;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_begin, log_end, log_level;</span><br><span class="line">  <span class="comment">// 部分辅助函数，此处无需关注</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; <span class="title">parse_args</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[];</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_help</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read_emu_regs</span><span class="params">(<span class="keyword">rtlreg_t</span> *r)</span></span>;   <span class="comment">// 从DUT顶层模块读取相关寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Emulator的构造函数</span></span><br><span class="line">  Emulator(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[]);</span><br><span class="line">  <span class="comment">// n个周期的复位</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset_ncycles</span><span class="params">(<span class="keyword">size_t</span> cycles)</span></span>;</span><br><span class="line">  <span class="comment">// 步进单个周期</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">single_cycle</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 执行n个周期</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute_cycles</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br><span class="line">  <span class="comment">// 测试Cache的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cache_test</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br><span class="line">  <span class="comment">// 执行，同时进行difftest</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 返回当前的周期数，用于Verilog的$time任务</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">get_cycles</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 返回最大的周期数，是通过构造函数设置的，防止卡死</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">get_max_cycles</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="read-emu-regs"><a href="#read-emu-regs" class="headerlink" title="read_emu_regs"></a><code>read_emu_regs</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read_emu_regs</span><span class="params">(<span class="keyword">rtlreg_t</span> *r)</span> </span>&#123;   <span class="comment">// 从DUT顶层模块读取相关寄存器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> macro(x) r[x] = dut_ptr-&gt;io_difftest_r_##x</span></span><br><span class="line">    macro(<span class="number">0</span>); macro(<span class="number">1</span>); macro(<span class="number">2</span>); macro(<span class="number">3</span>); macro(<span class="number">4</span>); macro(<span class="number">5</span>); macro(<span class="number">6</span>); macro(<span class="number">7</span>);</span><br><span class="line">    macro(<span class="number">8</span>); macro(<span class="number">9</span>); macro(<span class="number">10</span>); macro(<span class="number">11</span>); macro(<span class="number">12</span>); macro(<span class="number">13</span>); macro(<span class="number">14</span>); macro(<span class="number">15</span>);</span><br><span class="line">    macro(<span class="number">16</span>); macro(<span class="number">17</span>); macro(<span class="number">18</span>); macro(<span class="number">19</span>); macro(<span class="number">20</span>); macro(<span class="number">21</span>); macro(<span class="number">22</span>); macro(<span class="number">23</span>);</span><br><span class="line">    macro(<span class="number">24</span>); macro(<span class="number">25</span>); macro(<span class="number">26</span>); macro(<span class="number">27</span>); macro(<span class="number">28</span>); macro(<span class="number">29</span>); macro(<span class="number">30</span>); macro(<span class="number">31</span>);</span><br><span class="line">    r[DIFFTEST_THIS_PC] = dut_ptr-&gt;io_difftest_thisPC;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __RV32__                    <span class="comment">// 读取CSR寄存器，我们在顶层编译选项中定义的是RV64</span></span></span><br><span class="line">    r[DIFFTEST_MSTATUS] = dut_ptr-&gt;io_difftest_mstatus;</span><br><span class="line">    r[DIFFTEST_SSTATUS] = dut_ptr-&gt;io_difftest_sstatus;</span><br><span class="line">    r[DIFFTEST_MEPC   ] = dut_ptr-&gt;io_difftest_mepc;</span><br><span class="line">    r[DIFFTEST_SEPC   ] = dut_ptr-&gt;io_difftest_sepc;</span><br><span class="line">    r[DIFFTEST_MCAUSE ] = dut_ptr-&gt;io_difftest_mcause;</span><br><span class="line">    r[DIFFTEST_SCAUSE ] = dut_ptr-&gt;io_difftest_scause;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>将宏定义展开之后，我们看到，这个函数其实是依次将相关的寄存器dump出来，按顺序放入了一个<code>rtlreg_t</code>类型的变量中。（事实上，<code>rtlreg_t</code>变量也就是<code>uint64</code>的数组。如果是RV32，那么就是<code>uint32</code>，这个根据宏定义来开关，而宏定义是在编译的时候，通过编译选项指定的，详见Makefile）。</p>
<p>其中，剩下的例如<code>DIFFTEST_THIS_PC</code>等下标，在<code>difftest.h</code>中定义如下，PC作为32号，其余以此类推：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  DIFFTEST_THIS_PC = <span class="number">32</span>,</span><br><span class="line">#ifndef __RV32__</span><br><span class="line">  DIFFTEST_MSTATUS,</span><br><span class="line">  DIFFTEST_MCAUSE,</span><br><span class="line">  DIFFTEST_MEPC,</span><br><span class="line">  DIFFTEST_SSTATUS,</span><br><span class="line">  DIFFTEST_SCAUSE,</span><br><span class="line">  DIFFTEST_SEPC,</span><br><span class="line">#endif</span><br><span class="line">  DIFFTEST_NR_REG</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="初始化-构造函数"><a href="#初始化-构造函数" class="headerlink" title="初始化 - 构造函数"></a>初始化 - 构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">auto</span> args = parse_args(argc, argv);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// srand</span></span><br><span class="line">   srand(seed);</span><br><span class="line">   srand48(seed);</span><br><span class="line"><span class="comment">// 随机复位</span></span><br><span class="line">   Verilated::randReset(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置日志的起始时间和日志级别</span></span><br><span class="line">   dut_ptr-&gt;io_logCtrl_log_begin = log_begin;</span><br><span class="line">   dut_ptr-&gt;io_logCtrl_log_end = log_end;</span><br><span class="line">   dut_ptr-&gt;io_logCtrl_log_level = log_level;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用镜像来初始化ram</span></span><br><span class="line">   <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">init_ram</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *img)</span></span>;</span><br><span class="line">   init_ram(image);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化外部设备</span></span><br><span class="line">   <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">init_device</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">   init_device();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// init core</span></span><br><span class="line">   reset_ncycles(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="reset-ncycles-重置n个周期"><a href="#reset-ncycles-重置n个周期" class="headerlink" title="reset_ncycles - 重置n个周期"></a><code>reset_ncycles</code> - 重置n个周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i &#x3D; 0; i &lt; cycles; i++) &#123; &#x2F;&#x2F; 重置n个周期</span><br><span class="line">  dut_ptr-&gt;reset &#x3D; 1;</span><br><span class="line">  dut_ptr-&gt;clock &#x3D; 0;</span><br><span class="line">  dut_ptr-&gt;eval();</span><br><span class="line">  dut_ptr-&gt;clock &#x3D; 1;</span><br><span class="line">  dut_ptr-&gt;eval();</span><br><span class="line">  dut_ptr-&gt;reset &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="single-cycle-前进一个时钟周期（单步）"><a href="#single-cycle-前进一个时钟周期（单步）" class="headerlink" title="single_cycle() - 前进一个时钟周期（单步）"></a><code>single_cycle()</code> - 前进一个时钟周期（单步）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    dut_ptr-&gt;clock = <span class="number">0</span>;</span><br><span class="line">    dut_ptr-&gt;eval();</span><br><span class="line"></span><br><span class="line">    dut_ptr-&gt;clock = <span class="number">1</span>;</span><br><span class="line">    dut_ptr-&gt;eval();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VM_TRACE</span></span><br><span class="line">    tfp-&gt;dump(cycles);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    cycles ++;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此处使用了Verilator手册中提到的<code>eval()</code>。</p>
</li>
<li><p>当设置了时钟下降沿之后，调用<code>eval()</code>计算组合逻辑，设置了上升沿之后，调用<code>eval()</code>更新时序逻辑。</p>
</li>
<li><p>这里维护的<code>cycles</code>变量是为了给Verilog的<code>$time</code>任务使用，Verilator规定这个需要由用户维护。</p>
</li>
</ul>
<h4 id="execute-cycles-最核心的部分"><a href="#execute-cycles-最核心的部分" class="headerlink" title="execute_cycles - 最核心的部分"></a><code>execute_cycles</code> - 最核心的部分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute_cycles</span><span class="params">(<span class="keyword">uint64_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">is_finish</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">poll_event</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> <span class="title">uptime</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">set_abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> lasttime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> lastcommit = n;</span><br><span class="line">    <span class="keyword">int</span> hascommit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> stuck_limit = <span class="number">2000</span>;            <span class="comment">// 超过2000周期没有指令提交，可能会是卡住了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VM_TRACE</span></span><br><span class="line">    Verilated::traceEverOn(<span class="literal">true</span>);    <span class="comment">// Verilator must compute traced signals</span></span><br><span class="line">    VL_PRINTF(<span class="string">&quot;Enabling waves...\n&quot;</span>);</span><br><span class="line">    tfp = <span class="keyword">new</span> VerilatedVcdC;</span><br><span class="line">    dut_ptr-&gt;trace(tfp, <span class="number">99</span>);    <span class="comment">// Trace 99 levels of hierarchy</span></span><br><span class="line">    tfp-&gt;open(<span class="string">&quot;vlt_dump.vcd&quot;</span>);    <span class="comment">// Open the dump file</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!is_finish() &amp;&amp; n &gt; <span class="number">0</span>) &#123;    <span class="comment">// 主执行循环</span></span><br><span class="line">      single_cycle();</span><br><span class="line">      n --;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (lastcommit - n &gt; stuck_limit &amp;&amp; hascommit) &#123; <span class="comment">// 如果太久都没有指令提交，那说明有可能卡住了，强制停止</span></span><br><span class="line">        eprintf(<span class="string">&quot;No instruction commits for %d cycles, maybe get stuck\n&quot;</span></span><br><span class="line">            <span class="string">&quot;(please also check whether a fence.i instruction requires more than %d cycles to flush the icache)\n&quot;</span>,</span><br><span class="line">            stuck_limit, stuck_limit);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VM_TRACE</span></span><br><span class="line">        tfp-&gt;close();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        set_abort();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!hascommit &amp;&amp; (<span class="keyword">uint32_t</span>)dut_ptr-&gt;io_difftest_thisPC == <span class="number">0x80000000</span>) &#123;            <span class="comment">// 开始执行，初始PC=80000000</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        hascommit = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">init_difftest</span><span class="params">(<span class="keyword">rtlreg_t</span> *reg)</span></span>;</span><br><span class="line">        <span class="keyword">rtlreg_t</span> reg[DIFFTEST_NR_REG];</span><br><span class="line">        read_emu_regs(reg);</span><br><span class="line">        init_difftest(reg);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// difftest</span></span><br><span class="line">      <span class="keyword">if</span> (dut_ptr-&gt;io_difftest_commit &amp;&amp; hascommit) &#123;        <span class="comment">// 有提交的时候，就需要进行差分测试了</span></span><br><span class="line">        <span class="comment">// 将里面的所有reg都提取出来</span></span><br><span class="line">        <span class="keyword">rtlreg_t</span> reg[DIFFTEST_NR_REG];                        </span><br><span class="line">        read_emu_regs(reg);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">difftest_step</span><span class="params">(<span class="keyword">rtlreg_t</span> *reg_scala, <span class="keyword">uint32_t</span> this_inst,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">int</span> isMMIO, <span class="keyword">int</span> isRVC, <span class="keyword">int</span> isRVC2, <span class="keyword">uint64_t</span> intrNO, <span class="keyword">int</span> priviledgeMode, <span class="keyword">int</span> isMultiCommit)</span></span>;        </span><br><span class="line">          <span class="comment">// 这里有一个参数，如果是双提交的话，需要检测两次</span></span><br><span class="line">        <span class="keyword">if</span> (dut_ptr-&gt;io_difftestCtrl_enable) &#123;</span><br><span class="line">          <span class="keyword">if</span> (difftest_step(reg, dut_ptr-&gt;io_difftest_thisINST,                <span class="comment">// &lt;----------- PAY ATTENTION TO THIS FUNCTION !!!</span></span><br><span class="line">              dut_ptr-&gt;io_difftest_isMMIO, dut_ptr-&gt;io_difftest_isRVC, dut_ptr-&gt;io_difftest_isRVC2,</span><br><span class="line">              dut_ptr-&gt;io_difftest_intrNO, dut_ptr-&gt;io_difftest_priviledgeMode, </span><br><span class="line">              dut_ptr-&gt;io_difftest_isMultiCommit)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VM_TRACE</span></span><br><span class="line">            tfp-&gt;close();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            set_abort();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastcommit = n;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">uint32_t</span> t = uptime();</span><br><span class="line">      <span class="keyword">if</span> (t - lasttime &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        poll_event();</span><br><span class="line">        lasttime = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>difftest_step()</code></p>
</li>
<li><p><code>poll_event()</code></p>
</li>
<li><p>在开始仿真的时候，其实NEMU的状态是不确定的，需要在Reset之后，<strong>用我们编写的CPU的初始状态去校准NEMU的初始状态，他们一致之后，才会开始真正的仿真。</strong></p>
</li>
</ul>
<h4 id="difftest-step-灵魂"><a href="#difftest-step-灵魂" class="headerlink" title="difftest_step() - 灵魂"></a><code>difftest_step()</code> - 灵魂</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">difftest_step</span><span class="params">(<span class="keyword">rtlreg_t</span> *reg_scala, <span class="keyword">uint32_t</span> this_inst,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> isMMIO, <span class="keyword">int</span> isRVC, <span class="keyword">int</span> isRVC2, <span class="keyword">uint64_t</span> intrNO, <span class="keyword">int</span> priviledgeMode, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> isMultiCommit</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note:</span></span><br><span class="line">  <span class="comment">// reg_scala[DIFFTEST_THIS_PC] is the first PC commited by CPU-WB</span></span><br><span class="line">  <span class="comment">// ref_r[DIFFTEST_THIS_PC] is NEMU&#x27;s next PC</span></span><br><span class="line">  <span class="comment">// To skip the compare of an instruction, replace NEMU reg value with CPU&#x27;s regfile value,</span></span><br><span class="line">  <span class="comment">// then set NEMU&#x27;s PC to next PC to be run</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> DEBUG_RETIRE_TRACE_SIZE 16</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">rtlreg_t</span> ref_r[DIFFTEST_NR_REG];</span><br><span class="line">  <span class="keyword">rtlreg_t</span> this_pc = reg_scala[DIFFTEST_THIS_PC];</span><br><span class="line">  <span class="comment">// ref_difftest_getregs() will get the next pc,</span></span><br><span class="line">  <span class="comment">// therefore we must keep track this one</span></span><br><span class="line">  <span class="comment">// 需要注意的是：NEMU的PC是NEMU将要执行的下一条指令的PC</span></span><br><span class="line">  <span class="comment">// ref_difftest_getregs() 拿到的PC是NEMU计算出的下一个PC</span></span><br><span class="line">  <span class="comment">// 为了避免对比出错，我们需要用当前CPU执行的PC去覆盖读出的PC</span></span><br><span class="line">  <span class="comment">// 为了避免丢失原有的PC，我们需要将NEMU拿出来的下一个PC进行保存，保存到nemu_this_pc中</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">rtlreg_t</span> nemu_this_pc = <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="comment">// 这个循环队列，是用于记录之前的轨迹用的</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">rtlreg_t</span> pc_retire_queue[DEBUG_RETIRE_TRACE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> inst_retire_queue[DEBUG_RETIRE_TRACE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> multi_commit_queue[DEBUG_RETIRE_TRACE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> skip_queue[DEBUG_RETIRE_TRACE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> pc_retire_pointer = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> need_copy_pc = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> NO_DIFFTEST</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// Copy PC是什么机制？</span></span><br><span class="line">  <span class="comment">// 这个代码块的作用，猜测是仅在双提交+MMIO的情况下有用</span></span><br><span class="line">  <span class="comment">// 通过在代码中添加assert断言，确定其确实是在双提交的时候才有用</span></span><br><span class="line">  <span class="comment">// 在双提交，且为MMIO+跳转的模式下，下一个PC不应当是PC+8，而应当是跳转的目标</span></span><br><span class="line">  <span class="comment">// 我们假设DUT计算的跳转的目标永远是正确的，直接将其拷贝给NEMU</span></span><br><span class="line">  <span class="keyword">if</span> (need_copy_pc) &#123;</span><br><span class="line">    need_copy_pc = <span class="number">0</span>;</span><br><span class="line">    ref_difftest_getregs(&amp;ref_r);</span><br><span class="line">    nemu_this_pc = reg_scala[DIFFTEST_THIS_PC];</span><br><span class="line">    ref_r[DIFFTEST_THIS_PC] = reg_scala[DIFFTEST_THIS_PC];</span><br><span class="line">    ref_difftest_setregs(ref_r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMMIO) &#123;                </span><br><span class="line">    <span class="comment">// 对于MMIO，直接不对比，NEMU中的MMIO关系我们暂时无法干涉，所以直接跳过去，并且将执行完毕MMIO指令的CPU状态，拷贝到NEMU里面</span></span><br><span class="line">    <span class="comment">// printf(&quot;diff pc: %x isRVC %x\n&quot;, this_pc, isRVC);</span></span><br><span class="line">    <span class="comment">// MMIO accessing should not be a branch or jump, just +2/+4 to get the next pc</span></span><br><span class="line">    <span class="keyword">int</span> pc_skip = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 我们为什么很肯定地能认为NEMU的下一个PC是PC+4呢？</span></span><br><span class="line">    <span class="comment">// 在单提交的情况下，MMIO相关的不可能是跳转指令，所以PC+4一定是下一个PC</span></span><br><span class="line">    <span class="comment">// 所以直接将当前DUT的状态复制给NEMU，并且将NEMU的PC+4</span></span><br><span class="line">    <span class="comment">// 双提交的情况下，一定会是PC+8吗？这里需要多加考虑。</span></span><br><span class="line">    pc_skip += isRVC ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">    pc_skip += isMultiCommit ? (isRVC2 ? <span class="number">2</span> : <span class="number">4</span>) : <span class="number">0</span>;</span><br><span class="line">    reg_scala[DIFFTEST_THIS_PC] += pc_skip;</span><br><span class="line">    nemu_this_pc += pc_skip;</span><br><span class="line">    <span class="comment">// to skip the checking of an instruction, just copy the reg state to reference design</span></span><br><span class="line">    ref_difftest_setregs(reg_scala);        <span class="comment">// 把状态拷贝到里面去</span></span><br><span class="line">    <span class="comment">// 设置相关的队列</span></span><br><span class="line">    pc_retire_pointer = (pc_retire_pointer+<span class="number">1</span>) % DEBUG_RETIRE_TRACE_SIZE;</span><br><span class="line">    pc_retire_queue[pc_retire_pointer] = this_pc;</span><br><span class="line">    inst_retire_queue[pc_retire_pointer] = this_inst;</span><br><span class="line">    multi_commit_queue[pc_retire_pointer] = isMultiCommit;</span><br><span class="line">    skip_queue[pc_retire_pointer] = isMMIO;</span><br><span class="line">    <span class="comment">// 标记下一次需要覆盖PC（仅针对MMIO+跳转的双提交情形）</span></span><br><span class="line">    need_copy_pc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                        <span class="comment">// NEMU并不执行，直接return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (intrNO) &#123;                                                                <span class="comment">// 如果产生了中断或者异常，则NEMU也需要获知相关的信息</span></span><br><span class="line">    ref_difftest_raise_intr(intrNO);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ref_difftest_exec(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMultiCommit) &#123;    </span><br><span class="line">    ref_difftest_exec(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果是多提交，需要再运行一步</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ref_difftest_getregs(&amp;ref_r);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">rtlreg_t</span> next_pc = ref_r[<span class="number">32</span>];</span><br><span class="line">  pc_retire_pointer = (pc_retire_pointer+<span class="number">1</span>) % DEBUG_RETIRE_TRACE_SIZE;</span><br><span class="line">  pc_retire_queue[pc_retire_pointer] = this_pc;</span><br><span class="line">  inst_retire_queue[pc_retire_pointer] = this_inst;</span><br><span class="line">  multi_commit_queue[pc_retire_pointer] = isMultiCommit;</span><br><span class="line">  skip_queue[pc_retire_pointer] = isMMIO;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> isCSR = ((this_inst &amp; <span class="number">0x7f</span>) ==  <span class="number">0x73</span>);</span><br><span class="line">  <span class="keyword">int</span> isCSRMip = ((this_inst &gt;&gt; <span class="number">20</span>) == <span class="number">0x344</span>) &amp;&amp; isCSR;</span><br><span class="line">  <span class="keyword">if</span> (isCSRMip) &#123;</span><br><span class="line">    <span class="comment">// We can not handle NEMU.mip.mtip since it is driven by CLINT,</span></span><br><span class="line">    <span class="comment">// which is not accessed in NEMU due to MMIO.</span></span><br><span class="line">   <span class="comment">// Just sync the state of NEMU from NutCore.</span></span><br><span class="line">    reg_scala[DIFFTEST_THIS_PC] = next_pc;</span><br><span class="line">    nemu_this_pc = next_pc;</span><br><span class="line">    ref_difftest_setregs(reg_scala);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// replace with &quot;this pc&quot; for checking</span></span><br><span class="line">  <span class="comment">// 同步NEMU的PC</span></span><br><span class="line">  ref_r[DIFFTEST_THIS_PC] = nemu_this_pc;</span><br><span class="line">  <span class="comment">// 保存下一个PC</span></span><br><span class="line">  nemu_this_pc = next_pc;</span><br><span class="line"></span><br><span class="line">  ref_r[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 检查上面获得的结果，如果有误，打印出最近DEBUG_RETIRE_TRACE_SIZE条</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(reg_scala, ref_r, <span class="keyword">sizeof</span>(ref_r)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==============Retire Trace==============\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; DEBUG_RETIRE_TRACE_SIZE; j++)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;retire trace [%x]: pc %010lx inst %08x %s %s %s\n&quot;</span>, j, </span><br><span class="line">        pc_retire_queue[j], </span><br><span class="line">        inst_retire_queue[j], </span><br><span class="line">        (multi_commit_queue[j])?<span class="string">&quot;MC&quot;</span>:<span class="string">&quot;  &quot;</span>, </span><br><span class="line">        (skip_queue[j])?<span class="string">&quot;SKIP&quot;</span>:<span class="string">&quot;    &quot;</span>, </span><br><span class="line">        (j==pc_retire_pointer)?<span class="string">&quot;&lt;--&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n==============  Reg Diff  ==============\n&quot;</span>);</span><br><span class="line">    ref_isa_reg_display();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;priviledgeMode = %d\n&quot;</span>, priviledgeMode);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DIFFTEST_NR_REG; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reg_scala[i] != ref_r[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s different at pc = 0x%010lx, right= 0x%016lx, wrong = 0x%016lx\n&quot;</span>,</span><br><span class="line">            reg_name[i], this_pc, ref_r[i], reg_scala[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的有以下几个逻辑：</strong></p>
<ul>
<li>NEMU中的PC寄存器，指向的是<strong>下一个</strong>将要执行的指令的PC</li>
<li>进入<code>difftest_step()</code>函数时，NEMU的状态比DUT的状态<strong>滞后</strong>一条指令，但是<strong>NEMU的PC和DUT是相同的</strong></li>
<li>在NEMU单步执行一个周期之后，NEMU的通用寄存器和控制寄存器应当和DUT相同，但是NEMU的PC较DUT超前了一条指令。</li>
</ul>
<hr>
<ul>
<li>最重要的是需要理解<strong>PC跳过的逻辑</strong>，具体内容在代码中有详尽的注释。</li>
<li>对比一般流程如下：<ul>
<li>CPU提交一条指令</li>
<li>调用<code>difftest_step()</code></li>
<li>保存NEMU的PC(nemu_this_pc)</li>
<li>NEMU单步执行</li>
<li>对比</li>
</ul>
</li>
<li>如果是有需要跳过的指令<ul>
<li>CPU提交一条指令</li>
<li>调用<code>difftest_step()</code></li>
<li>拷贝CPU的状态给NEMU</li>
<li>更新NEMU的PC</li>
<li>返回</li>
</ul>
</li>
</ul>
<h5 id="need-copy-pc到底有啥用？"><a href="#need-copy-pc到底有啥用？" class="headerlink" title="need_copy_pc到底有啥用？"></a><code>need_copy_pc</code>到底有啥用？</h5><p>笔者在阅读源代码时，一直不理解这个<code>need_copy_pc</code>标志有什么用。</p>
<p><code>need_copy_pc</code>标志仅在<code>MMIO</code>这个分支内会被设置。</p>
<p>某天突然想到，之前实现的乱序处理器中，MMIO和跳转指令可能会同时提交，如果跳转指令发生了跳转，那么接下来，不可能会在PC+8的地方继续取指。那么在这种情况下，在<code>MMIO</code>这个分支中为NEMU设置的PC就不对了！</p>
<p>因为CPU在提交完MMIO和跳转指令这两条指令之后，接下来的PC不再是PC+8，而是会跳到目标地址，此时，<code>need_copy_pc</code>就派上用场了。根据作者的注释，在这种情况下，认为CPU计算的目标地址是正确的。</p>
<blockquote>
<p>笔者认为，此处的对比似乎不是那么严谨，如果需要跳过指令，并且双提交的情况，一个改进的措施是去除<code>need_copy_pc</code>这个标志，转而在CPU暴露的接口中指明跳转指令所在的PC，进而让NEMU也去执行对应的跳转指令，这样能够将测试覆盖的更加全面。</p>
<p>并且如果DUT为顺序标量处理器，是否可以使用宏来关闭这个<code>need_copy_pc</code>机制？因为在顺序标量的核中，这个选项确实是多余的，但是每次碰到MMIO，都会去执行这个分支，会不会造成效率的下降？</p>
</blockquote>
<h6 id="猜测与验证"><a href="#猜测与验证" class="headerlink" title="猜测与验证"></a>猜测与验证</h6><p>猜测：MMIO和跳转双提交的时候，会进入到这个条件之中，因为NEMU的PC需要校正。</p>
<p>为了验证自己的想法，笔者在关键部分添加了断言：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200901004921682.png"></p>
<ul>
<li><p>通过在此处添加断言，发现<code>need_copy_pc</code>这个条件似乎是多余的，那么事实是这样吗？</p>
</li>
<li><p>虽然每一次进入这个分支的时候，都复制了PC给NEMU，但是这个复制似乎是“多余”的，因为每次<code>assert</code>中的条件都成立。</p>
</li>
<li><p>在后面添加断言语句，断言是否有双提交，发现确实没有双提交</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200901004321667.png"></p>
<hr>
<p>进一步地，修改Nutshell的配置，配置为顺序双发射和乱序多发射。</p>
<ul>
<li>在顺序双发射的核中，也不存在MMIO与跳转指令同时提交的情况，唯有在乱序核中会有这种情况，所以当将参数调到如下情形时，断言才有不成立的可能。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200901010424899.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200901010449629.png" alt="image-20200901010449629"></p>
<hr>
<p><strong>结论：<code>need_copy_pc</code>仅在双提交，并且双提交为跳转指令+MMIO时才起作用。</strong></p>
<h3 id="device-cpp-ram-cpp-sdcard-cpp-uart-cpp-vga-cpp等-DPI-C接口"><a href="#device-cpp-ram-cpp-sdcard-cpp-uart-cpp-vga-cpp等-DPI-C接口" class="headerlink" title="device.cpp, ram.cpp, sdcard.cpp, uart.cpp, vga.cpp等 - DPI-C接口"></a><code>device.cpp, ram.cpp, sdcard.cpp, uart.cpp, vga.cpp等</code> - DPI-C接口</h3><p>Nutshell的仿真事实上也接近于<strong>全系统仿真</strong>，也就是说不仅仅仿真CPU核心，还需要同步仿真SoC上面的外设，例如内存、I/O设备。因此，Nutshell的源代码中提供了相应的C++编写的仿真模型。</p>
<p>一个很好的例子是串口模型。使用Verilog编写串口仿真模型，往往会比较困难，并且在命令行下难以与用户进行交互。而Verilog提供了DPI-C接口，可以在Verilog中调用编写好的C语言函数。</p>
<p>在<code>src/main/scala/device</code>中，是Nutshell提供的AXI外设模型，我们以串口模型为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UARTGetc</span> <span class="keyword">extends</span> <span class="title">BlackBox</span> <span class="keyword">with</span> <span class="title">HasBlackBoxInline</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> clk = <span class="type">Input</span>(<span class="type">Clock</span>())</span><br><span class="line">    <span class="keyword">val</span> getc = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> ch = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  setInline(<span class="string">&quot;UARTGetc.v&quot;</span>,</span><br><span class="line">    <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">      |import &quot;</span><span class="type">DPI</span>-<span class="type">C</span><span class="string">&quot; function void uart_getc(output byte ch);</span></span><br><span class="line"><span class="string">      |</span></span><br><span class="line"><span class="string">      |module UARTGetc (</span></span><br><span class="line"><span class="string">      |  input clk,</span></span><br><span class="line"><span class="string">      |  input getc,</span></span><br><span class="line"><span class="string">      |  output reg [7:0] ch</span></span><br><span class="line"><span class="string">      |);</span></span><br><span class="line"><span class="string">      |</span></span><br><span class="line"><span class="string">      |  always@(posedge clk) begin</span></span><br><span class="line"><span class="string">      |    if (getc) uart_getc(ch);</span></span><br><span class="line"><span class="string">      |  end</span></span><br><span class="line"><span class="string">      |</span></span><br><span class="line"><span class="string">      |endmodule</span></span><br><span class="line"><span class="string">     &quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到的是，在这个<code>UARTGetc</code>模块中，关联了外部的<code>uart_getc</code>函数，这个函数在控制台中能够接收用户输入，将输入存放在缓冲区中，当调用<code>uart_getc</code>函数的时候，能够返回缓冲区首部的字符，这里在Verilog中调用了C语言函数，能够直接将返回的字符传送给上层的硬件模块进行仿真。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AXI4UART</span> <span class="keyword">extends</span> <span class="title">AXI4SlaveModule</span>(<span class="params">new <span class="type">AXI4Lite</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> rxfifo = <span class="type">RegInit</span>(<span class="number">0.</span><span class="type">U</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> txfifo = <span class="type">Reg</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> stat = <span class="type">RegInit</span>(<span class="number">1.</span><span class="type">U</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> ctrl = <span class="type">RegInit</span>(<span class="number">0.</span><span class="type">U</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> getcHelper = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">UARTGetc</span>)</span><br><span class="line">  getcHelper.io.clk := clock</span><br><span class="line">  getcHelper.io.getc := (raddr(<span class="number">3</span>,<span class="number">0</span>) === <span class="number">0.</span><span class="type">U</span> &amp;&amp; ren)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">putc</span></span>(c: <span class="type">UInt</span>): <span class="type">UInt</span> = &#123; printf(<span class="string">&quot;%c&quot;</span>, c(<span class="number">7</span>,<span class="number">0</span>)); c &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getc</span> </span>= getcHelper.io.ch</span><br></pre></td></tr></table></figure>

<p>那么串口输出就比较简单了，直接调用<code>scala</code>的输出函数就可以实现。</p>
<p>有关于DPI-C以及相关仿真模型的细节，由于时间所限，此处不一一描述。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/30/Verilator_note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/30/Verilator_note/" class="post-title-link" itemprop="url">Verilator仿真器入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-30 01:00:00" itemprop="dateCreated datePublished" datetime="2020-08-30T01:00:00+08:00">2020-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>和我们平时熟悉的<code>xsim</code>仿真器不同，Verilator是一款高性能的仿真器，其高性能的秘诀就在于将Verilog代码编译成C++模型进行执行，这样可以达到多线程仿真的效果。</p>
<p><strong>如果想要理解使用模拟器（例如NEMU）进行差分测试的原理，就必须理解Verilator仿真的机制和流程。</strong></p>
<p><strong>本文总结了理解差分测试程序需要的Verilator预备知识。</strong></p>
<h2 id="Verilator仿真全流程"><a href="#Verilator仿真全流程" class="headerlink" title="Verilator仿真全流程"></a>Verilator仿真全流程</h2><ol>
<li>类似于GCC的，我们调用<code>verilator</code>可执行文件，后接相关的Verilog源文件，<code>verilator</code>将Verilog源文件编译为C++模型或者System C模型。在手册中，他们把这个叫做<code>verilating</code>，输出的模型叫做<code>verilated</code>的模型。</li>
<li>Verilate完成之后，并不是万事大吉，用户需要编写一个C++的<code>wrapper</code>模块，其中包含<code>main()</code>函数，实例化了编译好的模型。</li>
<li>使用C++编译器，将Verilator编译好的模型、用户编写的顶层<code>wrapper</code>和Verilator提供的库函数编译成可执行的仿真文件。</li>
<li>执行可执行文件，完成仿真。</li>
</ol>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p><code>our.v</code>:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> our;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span> <span class="built_in">$display</span>(<span class="string">&quot;Hello World&quot;</span>); <span class="built_in">$finish</span>; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><code>sim_main.cpp</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Vour.h&quot;</span>    <span class="comment">// Verilog模块会被编译成Vxxx</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;verilated.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **env)</span></span>&#123;</span><br><span class="line">    Verilated::commandArgs(argc, argv);            <span class="comment">// Verilator仿真运行时参数（和编译的参数不一样，详见Verilator手册第6章</span></span><br><span class="line">    Vour *top = <span class="keyword">new</span> Vour;</span><br><span class="line">    <span class="keyword">while</span> (!Verilated::gotFinish()) &#123; top-&gt;eval(); &#125;</span><br><span class="line">    <span class="keyword">delete</span> top;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用相关的命令进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verilator -Wall --cc our.v --exe --build sim_main.cpp</span><br></pre></td></tr></table></figure>

<h2 id="仿真过程"><a href="#仿真过程" class="headerlink" title="仿真过程"></a>仿真过程</h2><p>当我们使用C++模型进行仿真的时候，用户编写的顶层函数必须调用<code>eval()</code>或者<code>eval_step()</code>和<code>eval_end_step()</code>。</p>
<p>当我们在C++层面，仅仅实例化一个模型的时候，只需要调用<code>designPtr-&gt;eval()</code>，事实上，<code>eval()</code>和<code>eval_step()+eval_end_step()</code>等效。</p>
<p><strong>当每次<code>eval()</code>被调用的时候，就会执行一次<code>always @(posedge clk)</code>语句，计算相应的结果，然后计算组合逻辑。</strong></p>
<h2 id="和C-的交互"><a href="#和C-的交互" class="headerlink" title="和C++的交互"></a>和C++的交互</h2><p>对于Verilator而言，会对顶层测试模块创建一个<code>Vxxx.h</code>和<code>Vxxx.c</code>文件，还有其他的模块文件，此处我们并不关注。</p>
<p>在编译的过程中，还会有<code>Vxxx.mk</code>文件，目标文件是<code>Vxxx_ALL.a</code>文件，会和用户编写的C++主函数中的循环链接，并创建出仿真的可执行文件。</p>
<p>我们来看以下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;verilated.h&gt; // Defines common routines</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // Need std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Vtop.h&quot;</span> <span class="comment">// From Verilating &quot;top.v&quot;</span></span></span><br><span class="line"></span><br><span class="line">Vtop *top; <span class="comment">// 模块的实例</span></span><br><span class="line"><span class="keyword">vluint64_t</span> main_time = <span class="number">0</span>; <span class="comment">// 当前的仿真时间</span></span><br><span class="line"><span class="comment">// This is a 64-bit integer to reduce wrap over issues and</span></span><br><span class="line"><span class="comment">// allow modulus. This is in units of the timeprecision</span></span><br><span class="line"><span class="comment">// used in Verilog (or from --timescale-override)</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sc_time_stamp</span><span class="params">()</span> </span>&#123; <span class="comment">// Called by $time in Verilog</span></span><br><span class="line">    <span class="keyword">return</span> main_time; <span class="comment">// 需要被Verilog中的$time调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    Verilated::commandArgs(argc, argv); <span class="comment">// Remember args</span></span><br><span class="line">    top = <span class="keyword">new</span> Vtop; <span class="comment">// 创建一个新的实例</span></span><br><span class="line">    top-&gt;reset_l = <span class="number">0</span>; <span class="comment">// 把reset拉低</span></span><br><span class="line">    <span class="keyword">while</span> (!Verilated::gotFinish()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (main_time &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            top-&gt;reset_l = <span class="number">1</span>; <span class="comment">// Deassert reset        // 拉高Reset，结束复位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((main_time % <span class="number">10</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            top-&gt;clk = <span class="number">1</span>; <span class="comment">// 时钟翻转</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((main_time % <span class="number">10</span>) == <span class="number">6</span>) &#123;</span><br><span class="line">            top-&gt;clk = <span class="number">0</span>; <span class="comment">// 时钟翻转</span></span><br><span class="line">        &#125;</span><br><span class="line">        top-&gt;eval(); <span class="comment">// 计算输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; top-&gt;out &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// Read a output</span></span><br><span class="line">        main_time++; <span class="comment">// 时间戳自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    top-&gt;<span class="keyword">final</span>(); <span class="comment">// 仿真结束的时候，需要运行final()来执行所有的final块</span></span><br><span class="line"><span class="comment">// // (Though this example doesn&#x27;t get here)</span></span><br><span class="line">    <span class="keyword">delete</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由上面代码可见，仿真时如果需要访问模块的顶层信号，可以使用<code>top-&gt;signal</code>的形式进行访问。</strong></p>
<h2 id="DPI（直接编程接口）"><a href="#DPI（直接编程接口）" class="headerlink" title="DPI（直接编程接口）"></a>DPI（直接编程接口）</h2><h3 id="一个简单的例子-1"><a href="#一个简单的例子-1" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>如果我们想在Verilog中调用C语言编写的函数，可以在<code>our.v</code>的头部声明：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;DPI-C&quot;</span> <span class="keyword">function</span> <span class="keyword">int</span> add (<span class="keyword">input</span> <span class="keyword">int</span> a, <span class="keyword">input</span> <span class="keyword">int</span> b);</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;%x + %x = %x&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>

<p>在Verilator编译之后，将会创建一个<code>Vour__Dpi.h</code>文件，里面有以下的extern声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此后，在其他文件中实现这个<code>add</code>函数，记住，需要包含两个头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;svdpi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Vour__Dpi.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="DPI系统任务-函数"><a href="#DPI系统任务-函数" class="headerlink" title="DPI系统任务/函数"></a>DPI系统任务/函数</h3><p>Verilator还支持将外部的C函数作为系统函数，需要使用<code>$</code>作为前缀，但注意，<code>$</code>前缀需要被转义：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">&quot;DPI-C&quot;</span> <span class="keyword">function</span> <span class="keyword">integer</span> \$myRand;</span><br><span class="line"><span class="keyword">initial</span> <span class="built_in">$display</span>(<span class="string">&quot;myRand=%d&quot;</span>, $myRand());</span><br></pre></td></tr></table></figure>

<hr>
<p>同样地，我们也可以将Verilog中的task导出为C++函数：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="string">&quot;DPI-C&quot;</span> <span class="keyword">task</span> publicSetBool;</span><br><span class="line"><span class="keyword">task</span> publicSetBool;</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">bit</span> in_bool;</span><br><span class="line">    var_bool = in_bool;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>

<p>在”Verilate”之后，Verilator就会创建一个<code>Vour__Dpi.h</code>文件，其中有相应函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">publicSetBool</span><span class="params">(svBit in_bool)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以在<code>sc_main.cpp</code>文件中条用相关的函数了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Vour__Dpi.h&quot;</span></span></span><br><span class="line">publicSetBool(value);</span><br></pre></td></tr></table></figure>

<p>或者以如下的形式显式调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Vour__Dpi.h&quot;</span></span></span><br><span class="line">Vour::publicSetBool(value);</span><br><span class="line"><span class="comment">// or top-&gt;publicSetBool(value);</span></span><br></pre></td></tr></table></figure>

<p>关于更多DPI的使用方法，可以参考Verilator的官方手册第15章：<a target="_blank" rel="noopener" href="https://www.veripool.org/ftp/verilator_doc.pdf">https://www.veripool.org/ftp/verilator_doc.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/26/Chisel_Note_13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/Chisel_Note_13/" class="post-title-link" itemprop="url">Chisel学习笔记（十三）：类型系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-26 02:00:00" itemprop="dateCreated datePublished" datetime="2020-08-26T02:00:00+08:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Scala是强类型语言。类似于Python这种动态类型语言，在解释执行的时候出现的错误，可能会在Scala的编译阶段出现，因此，在编译阶段报错，能够尽可能地减少运行时错误。</p>
<p>在这一节中，我们将讨论“类型是Scala中的一等公民”这个话题。</p>
<h2 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h2><p>Scala中的所有对象都有类型，常常是该对象所属的class，可以通过<code>getClass</code>方法取得。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="number">10.</span>getClass)</span><br><span class="line">println(<span class="number">10.0</span>.getClass)</span><br><span class="line">println(<span class="string">&quot;ten&quot;</span>.getClass)</span><br></pre></td></tr></table></figure>

<p>强烈推荐在声明函数的时候定义输入和输出的类型，以避免奇怪的错误。特别是，对于重载过的运算符而言。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span></span>(s: <span class="type">String</span>): <span class="type">String</span> = s + s</span><br><span class="line"><span class="comment">// double(&quot;hi&quot;)      // 正确用法</span></span><br><span class="line"><span class="comment">// double(10)        // 编译报错</span></span><br><span class="line"><span class="comment">// double(&quot;hi&quot;) / 10 // 编译报错</span></span><br></pre></td></tr></table></figure>

<p>返回值类型为<code>Unit</code>的函数不返回任何东西。</p>
<h2 id="Scala类型-VS-Chisel类型"><a href="#Scala类型-VS-Chisel类型" class="headerlink" title="Scala类型 VS. Chisel类型"></a>Scala类型 VS. Chisel类型</h2><p>以下的代码是合法的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">4.</span><span class="type">W</span>))</span><br><span class="line">a := <span class="number">0.</span><span class="type">U</span></span><br></pre></td></tr></table></figure>
<p>因为<code>0.U</code> 是<code>UInt</code> ，是Chisel类型。</p>
<p>而以下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">4.</span><span class="type">W</span>))</span><br><span class="line">a := <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>是非法的，因为0是 <code>Int</code> ，是Scala类型。</p>
<p>对于 <code>Bool</code>而言也是如此，在Chisel中是<code>Boolean</code>类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bool = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line"><span class="keyword">val</span> boolean: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// legal</span></span><br><span class="line">when (bool) &#123; ... &#125;</span><br><span class="line"><span class="keyword">if</span> (boolean) &#123; ... &#125;</span><br><span class="line"><span class="comment">// illegal</span></span><br><span class="line"><span class="keyword">if</span> (bool) &#123; ... &#125;</span><br><span class="line">when (boolean) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>在编译的时候，Scala会做静态类型检查，所以能够找到类型不匹配的问题。</p>
<h2 id="Scala类型转换"><a href="#Scala类型转换" class="headerlink" title="Scala类型转换"></a>Scala类型转换</h2><h3 id="asInstanceOf"><a href="#asInstanceOf" class="headerlink" title="asInstanceOf"></a>asInstanceOf</h3><p><code>x.asInstanceOf[T]</code> 将对象 <code>x</code> 转换成<code>T</code>类型。当无法转换时，将抛出异常。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: <span class="type">UInt</span> = <span class="number">3.</span><span class="type">U</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  println(x.asInstanceOf[<span class="type">Int</span>])</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: java.lang.<span class="type">ClassCastException</span> =&gt; println(<span class="string">&quot;As expected, we can&#x27;t cast UInt to Int&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// But we can cast UInt to Data since UInt inherits from Data.</span></span><br><span class="line">println(x.asInstanceOf[<span class="type">Data</span>])</span><br></pre></td></tr></table></figure>

<p>在上面的运行结果中，UInt不能转换成Int。</p>
<h3 id="Chisel中的类型转换"><a href="#Chisel中的类型转换" class="headerlink" title="Chisel中的类型转换"></a>Chisel中的类型转换</h3><h3 id="Type-Casting-in-Chisel"><a href="#Type-Casting-in-Chisel" class="headerlink" title="Type Casting in Chisel"></a>Type Casting in Chisel</h3><p>下面代码的问题在于，强行地将一个<code>UInt</code> 赋值给了<code>SInt</code>，这在Chisel中是不允许的。</p>
<p>Chisel拥有一系列的类型转换函数，最常用的就是 <code>asTypeOf()</code>，其参数应该是某个Chisel信号。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeConvertDemo</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> in  = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">4.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">SInt</span>(<span class="number">4.</span><span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    io.out := io.in<span class="comment">//应当加上.asTypeOf(io.out) </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些时候，我们还需要使用<code>asUInt()</code>和<code>asSInt()</code>。</p>
<h2 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h2><h3 id="匹配操作"><a href="#匹配操作" class="headerlink" title="匹配操作"></a>匹配操作</h3><p>在之前，我们讨论过类型匹配的问题。类型匹配包含于Scala的模式匹配机制之内，对于编写那些“通用类型”的代码，非常有用。</p>
<p>下面的例子中介绍了一种能够进行<code>UInt</code>和<code>SInt</code>的类型匹配机制。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstantSum</span>(<span class="params">in1: <span class="type">Data</span>, in2: <span class="type">Data</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> out = <span class="type">Output</span>(in1.cloneType)</span><br><span class="line">    &#125;)</span><br><span class="line">    (in1, in2) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> (x: <span class="type">UInt</span>, y: <span class="type">UInt</span>) =&gt; io.out := x + y</span><br><span class="line">        <span class="keyword">case</span> (x: <span class="type">SInt</span>, y: <span class="type">SInt</span>) =&gt; io.out := x + y</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">&quot;I give up!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Data</code>是Chisel中所有类型的超类，能够接收所有Chisel类型的参数。</p>
<p>注意：模式匹配仅仅能够使用在电路生成阶段，这是Scala的语法，而并不能对应到实际的电路中。</p>
<p>例如，下面的代码就有问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputIsZero</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> in  = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">    io.out := (io.in <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="comment">// note that case 0.U is an error</span></span><br><span class="line">        <span class="keyword">case</span> (<span class="number">0.</span><span class="type">U</span>) =&gt; <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">        <span class="keyword">case</span> _   =&gt; <span class="literal">false</span>.<span class="type">B</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unapply方法"><a href="#Unapply方法" class="headerlink" title="Unapply方法"></a>Unapply方法</h3><p>为什么我们可以直接做这样的类型匹配？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span>(<span class="params">a: <span class="type">String</span>, b: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">a</span> </span>= <span class="type">Something</span>(<span class="string">&quot;A&quot;</span>, <span class="number">3</span>)</span><br><span class="line">a <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Something</span>(<span class="string">&quot;A&quot;</span>, value) =&gt; value</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Something</span>(str, <span class="number">3</span>)     =&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个Case Class，Scala自动为其生成了<code>unapply</code>方法。这是一种语法糖，<strong>能够让<code>match</code>语句在匹配类型的同时，将对象中的值提取出来进行匹配</strong>。</p>
<p>让我们来看下面一个例子，例如，我们确定一个参数，如果<code>pipelineMe</code>为真，则取<code>delay</code>为 <code>3*totalWidth</code>；如果为假，则取为<code>2*someOtherWidth</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeGeneratorParameters</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    someWidth: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    someOtherWidth: <span class="type">Int</span> = 10,</span></span></span><br><span class="line"><span class="class"><span class="params">    pipelineMe: <span class="type">Boolean</span> = false</span></span></span><br><span class="line"><span class="class"><span class="params"></span>) </span>&#123;</span><br><span class="line">    require(someWidth &gt;= <span class="number">0</span>)</span><br><span class="line">    require(someOtherWidth &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> totalWidth = someWidth + someOtherWidth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span></span>(p: <span class="type">SomeGeneratorParameters</span>): <span class="type">Int</span> = p <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> sg @ <span class="type">SomeGeneratorParameters</span>(_, _, <span class="literal">true</span>) =&gt; sg.totalWidth * <span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SomeGeneratorParameters</span>(_, sw, <span class="literal">false</span>) =&gt; sw * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，这个<code>case</code>引用了实例中的字段。</p>
<p>下面的这种语法，能够让我们同时引用对象用于匹配的内部的值，同时引用其父对象<code>sg</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> sg<span class="meta">@SomeGeneratorParameters</span>(_, sw, <span class="literal">true</span>) =&gt; sw</span><br></pre></td></tr></table></figure>

<p>如果我们想对某个非case class采用<code>unapply</code>方法，可以手动在其伴生对象中写入：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span>(<span class="params">val name: <span class="type">String</span>, val length: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(b: <span class="type">Boat</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Some</span>((b.name, b.length))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, length: <span class="type">Int</span>): <span class="type">Boat</span> = <span class="keyword">new</span> <span class="type">Boat</span>(name, length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSmallBoats</span></span>(seq: <span class="type">Seq</span>[<span class="type">Boat</span>]): <span class="type">Seq</span>[<span class="type">Boat</span>] = seq.filter &#123; b =&gt;</span><br><span class="line">    b <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Boat</span>(_, length) <span class="keyword">if</span> length &lt; <span class="number">60</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Boat</span>(_, _) =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> boats = <span class="type">Seq</span>(<span class="type">Boat</span>(<span class="string">&quot;Santa Maria&quot;</span>, <span class="number">62</span>), <span class="type">Boat</span>(<span class="string">&quot;Pinta&quot;</span>, <span class="number">56</span>), <span class="type">Boat</span>(<span class="string">&quot;Nina&quot;</span>, <span class="number">50</span>))</span><br><span class="line">println(getSmallBoats(boats).map(_.name).mkString(<span class="string">&quot; and &quot;</span>) + <span class="string">&quot; are small boats!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Chisel的类型层级"><a href="#Chisel的类型层级" class="headerlink" title="Chisel的类型层级"></a>Chisel的类型层级</h2><p><code>chisel3.Data</code> 是所有Chisel硬件类型的基类。 <code>UInt</code>, <code>SInt</code>, <code>Vec</code>, <code>Bundle</code>等都是<code>Data</code>的子类。 <code>Data</code> 可以被用于IO，并且支持被<code>:=</code>赋值，例如wires, regs等。</p>
<p>在Chisel中，寄存器是多态类型的代表。 对于<code>RegEnable</code>寄存器的实现，如果想要其支持通用类型，最关键的就是那句<code>[T &lt;: Data]</code>，使得<code>RegEnable</code>对于Chisel所有的硬件类型都能够工作。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](next: <span class="type">T</span>, enable: <span class="type">Bool</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> r = <span class="type">Reg</span>(chiselTypeOf(next))</span><br><span class="line">    when (enable) &#123; r := next &#125;</span><br><span class="line">    r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些操作符仅仅对于 <code>Bits</code>有定义，例如<code>+</code>。这就是你可以累加<code>UInt</code> 或<code>SInt</code>，但不能累加<code>Bundle</code>或<code>Vec</code>的原因。</p>
<h3 id="例子：通用类型的移位寄存器"><a href="#例子：通用类型的移位寄存器" class="headerlink" title="例子：通用类型的移位寄存器"></a>例子：通用类型的移位寄存器</h3><p>在Scala中，不仅仅是对象和函数可以当作参数，类型也可以当作参数。</p>
<p>我们通常需要提供类型相关的限制，在这个情况下，我们需要将信号放在一个<code>Bundle</code>里面，<code>:=</code>连接他们，并以其创建一个寄存器。</p>
<p>赋值语句不能随便进行，例如，<code>wire := 3</code>是不合法的，因为3是Scala的整数类型，并不是Chisel的<code>UInt</code>类型。如果我们创建了一个类型约束，并且声明<code>T</code>是Data的子类，那么我们就可以自由地使用<code>:=</code>了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShiftRegisterIO</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    require (n &gt;= <span class="number">0</span>, <span class="string">&quot;Shift register must have non-negative shift&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(gen.cloneType)</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">Vec</span>(n + <span class="number">1</span>, gen.cloneType)) <span class="comment">// + 1 because in is included in out</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">cloneType</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span> = (<span class="keyword">new</span> ShiftRegisterIO(gen, n)).asInstanceOf[<span class="keyword">this</span>.<span class="keyword">type</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShiftRegister</span>[<span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">gen: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">ShiftRegisterIO</span>(gen, n))</span><br><span class="line">    </span><br><span class="line">    io.out.foldLeft(io.in) &#123; <span class="keyword">case</span> (in, out) =&gt;</span><br><span class="line">        out := in</span><br><span class="line">        <span class="type">RegNext</span>(in)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解：上面的<code>foldLeft</code>方法有点绕，需要一定时间理解。</p>
<p>（TBC）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/25/Chisel_Note_12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Chisel_Note_12/" class="post-title-link" itemprop="url">Chisel学习笔记（十二）：面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 22:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T22:00:00+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Chisel基于Scala，而Scala支持面向对象的编程范式，也就是说，代码可以被分割成不同的对象。</p>
<h2 id="Scala中的面向对象"><a href="#Scala中的面向对象" class="headerlink" title="Scala中的面向对象"></a>Scala中的面向对象</h2><p>在这一节中，我们将展示Scala是如何实现面向对象的编程范式的。在面向对象的编程中，Scala还拥有以下的特性：</p>
<ul>
<li>抽象类（Abstract class）</li>
<li>特质（Traits）</li>
<li>对象（Objects）</li>
<li>伴生对象（Companion Objects）</li>
<li>案例类（Case Classes）</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>对于抽象类，熟悉面向对象的人应该不陌生了。在抽象类中，我们定义一些继承他的子类必须实现的字段。</p>
<p>任何对象只能从最多一个抽象类中继承。</p>
<p>以下是抽象类的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myFunction</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">  <span class="keyword">val</span> myValue: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">MyAbstractClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myFunction</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = i + <span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> myValue = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// val abstractClass = new MyAbstractClass() // 这段代码不能编译，因为抽象类的部分字段没有实现</span></span><br><span class="line"><span class="keyword">val</span> concreteClass = <span class="keyword">new</span> <span class="type">ConcreteClass</span>()      <span class="comment">// 这段代码是合法代码</span></span><br></pre></td></tr></table></figure>

<h3 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h3><p>特质和抽象类非常相似，在于他们都可以定义“未实现”的字段。特质和抽象类有两点不同：</p>
<ul>
<li>一个类可以从多个特质继承而来</li>
<li>一个特质不能拥有构造函数的参数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HasFunction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">myFunction</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HasValue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> myValue: <span class="type">String</span></span><br><span class="line">  <span class="keyword">val</span> myOtherValue = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">HasFunction</span> <span class="keyword">with</span> <span class="title">HasValue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">myFunction</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = i + <span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> myValue = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncomment below to test!</span></span><br><span class="line"><span class="comment">// val myTraitFunction = new HasFunction() // Illegal! Cannot instantiate a trait</span></span><br><span class="line"><span class="comment">// val myTraitValue = new HasValue()       // Illegal! Cannot instantiate a trait</span></span><br><span class="line"><span class="keyword">val</span> myClass = <span class="keyword">new</span> <span class="type">MyClass</span>()                <span class="comment">// Legal!</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，请多多使用特质，而非抽象类，除非我们能够确保仅仅从抽象类做单继承。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于单例的类（仅有一个对象的类），可以创建一个单独的Object。</p>
<p>Object不能被实例化，我们可以直接引用这个对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hi</span></span>: <span class="type">String</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(msg: <span class="type">String</span>) = msg</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="type">MyObject</span>.hi)</span><br><span class="line">println(<span class="type">MyObject</span>(<span class="string">&quot;This message is important!&quot;</span>)) <span class="comment">// equivalent to MyObject.apply(msg)</span></span><br></pre></td></tr></table></figure>

<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>当一个类和一个对象的<strong>名字相同，且位于同一个文件中</strong>时，这个对象可以称为是<strong>伴生对象</strong>。</p>
<p>当在名字前面看到<code>new</code>关键字的时候，它将创建一个类的实例；当没有使用<code>new</code>的时候，它将指向伴生对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Lion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roar</span></span>(): <span class="type">Unit</span> = println(<span class="string">&quot;I&#x27;M AN OBJECT!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roar</span></span>(): <span class="type">Unit</span> = println(<span class="string">&quot;I&#x27;M A CLASS!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="type">Lion</span>().roar()</span><br><span class="line"><span class="type">Lion</span>.roar()</span><br></pre></td></tr></table></figure>

<p>我们为什么要使用伴生对象呢？原因有几个：</p>
<ul>
<li>维护那些和类有关的常量</li>
<li>在运行类的构造函数之前/之后，运行一些其他的代码</li>
<li>创建一个类的很多个构造函数</li>
</ul>
<hr>
<p>看下面代码的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> defaultName = <span class="string">&quot;Bigfoot&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> numberOfAnimals = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>): <span class="type">Animal</span> = &#123;</span><br><span class="line">        numberOfAnimals += <span class="number">1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="type">Animal</span>(name, numberOfAnimals)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">Animal</span> = apply(defaultName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">name: <span class="type">String</span>, order: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>: <span class="type">String</span> = <span class="string">s&quot;Hi my name is <span class="subst">$name</span>, and I&#x27;m <span class="subst">$order</span> in line!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bunny = <span class="type">Animal</span>.apply(<span class="string">&quot;Hopper&quot;</span>) <span class="comment">// Calls the Animal factory method</span></span><br><span class="line">println(bunny.info)</span><br><span class="line"><span class="keyword">val</span> cat = <span class="type">Animal</span>(<span class="string">&quot;Whiskers&quot;</span>)       <span class="comment">// Calls the Animal factory method</span></span><br><span class="line">println(cat.info)</span><br><span class="line"><span class="keyword">val</span> yeti = <span class="type">Animal</span>()                <span class="comment">// Calls the Animal factory method</span></span><br><span class="line">println(yeti.info)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Animal</code>伴生对象定义了一个和<code>Animal</code>类有关的常量：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> defaultName = <span class="string">&quot;Bigfoot&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并且给出了一个可变的字段，来记录创建的实例数量：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> numberOfAnimals = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后定义了两个<code>apply</code>方法，我们称之为<strong>工厂方法</strong>，能够返回<code>Animal</code>类的实例</p>
<ul>
<li>第一个方法，传入动物名称，并将总计数器+1，返回新的实例</li>
<li>第二个方法，以默认名称创建实例</li>
</ul>
</li>
<li><p>工厂方法可以以以下的形式调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bunny = <span class="type">Animal</span>.apply(<span class="string">&quot;Hopper&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也可以省略<code>apply</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bunny = <span class="type">Animal</span>(<span class="string">&quot;Hopper&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂方法常常通过伴生对象提供，在我们创建实例时，调用工厂方法的<code>apply</code>，可以省略关键字<code>new</code>。</p>
<hr>
<p>在Chisel中，经常使用工厂方法，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myModule = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">MyModule</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="案例类"><a href="#案例类" class="headerlink" title="案例类"></a>案例类</h3><p>案例类是Scala类的一个特别的类型，在Scala编程中十分常见。具有以下特性：</p>
<ul>
<li>对于类的任何参数，外部都可以访问</li>
<li>可以不使用<code>new</code>来实例化新的对象</li>
<li>自动创建一个<code>unapply</code>方法，支持对类所有参数的访问</li>
<li>不能被继承</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nail</span>(<span class="params">length: <span class="type">Int</span></span>) <span class="title">//</span> <span class="title">Regular</span> <span class="title">class</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">nail</span> </span>= <span class="keyword">new</span> <span class="type">Nail</span>(<span class="number">10</span>) <span class="comment">// Requires the `new` keyword</span></span><br><span class="line"><span class="comment">// println(nail.length) // Illegal! Class constructor parameters are not by default externally visible</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screw</span>(<span class="params">val threadSpace: <span class="type">Int</span></span>) <span class="title">//</span> <span class="title">By</span> <span class="title">using</span> <span class="title">the</span> `<span class="title">val</span>` <span class="title">keyword</span>, <span class="title">threadSpace</span> <span class="title">is</span> <span class="title">now</span> <span class="title">externally</span> <span class="title">visible</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">screw</span> </span>= <span class="keyword">new</span> <span class="type">Screw</span>(<span class="number">2</span>)          <span class="comment">// Requires the `new` keyword</span></span><br><span class="line">println(screw.threadSpace)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Staple</span>(<span class="params">isClosed: <span class="type">Boolean</span></span>) <span class="title">//</span> <span class="title">Case</span> <span class="title">class</span> <span class="title">constructor</span> <span class="title">parameters</span> <span class="title">are</span>, <span class="title">by</span> <span class="title">default</span>, <span class="title">externally</span> <span class="title">visible</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">staple</span> </span>= <span class="type">Staple</span>(<span class="literal">false</span>)           <span class="comment">// No `new` keyword required</span></span><br><span class="line">println(staple.isClosed)</span><br></pre></td></tr></table></figure>

<p><code>Nail</code>是一个常规的类，它的参数并不能在外部可见，因为在定义时，并没有使用<code>val</code>关键字；同时，实例化<code>Nail</code>需要<code>new</code>关键字。</p>
<p><code>Screw</code> 的声明类似于<code>Nail</code>, 但是在参数列表中使用了 <code>val</code> 关键字。这使得其字段 <code>threadSpace</code>对外部可见的。</p>
<p>使用案例类声明的 <code>Staple</code> 其参数对外部均可见。并且，在创建对象的时候，不需要使用<code>new</code>关键字，因为Scala自动为每一个<code>case class</code>创建了伴生类。</p>
<h2 id="在Chisel中使用继承"><a href="#在Chisel中使用继承" class="headerlink" title="在Chisel中使用继承"></a>在Chisel中使用继承</h2><p>我们之前使用过Bundle和Module。事实上，每一个我们创建的Chisel模块，都继承自基类<code>Module</code>，每一个IO都继承自基类<code>Bundle</code>。Chisel的类型<code>UInt</code>或者<code>Bundle</code>都以<code>Data</code>为超类。</p>
<h3 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h3><p>当我们在Chisel中创建一个硬件模块的时候，我们都需要从<code>Module</code>类继承过来。继承不一定是复用的最佳手段，但仍然是一个非常有利的工具。</p>
<h4 id="例子：格雷码编码器和解码器（待续）"><a href="#例子：格雷码编码器和解码器（待续）" class="headerlink" title="例子：格雷码编码器和解码器（待续）"></a>例子：格雷码编码器和解码器（待续）</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoGlitchCounterIO</span>(<span class="params">bitwidth: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> en  = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(bitwidth.<span class="type">W</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NoGlitchCounter</span>(<span class="params">val maxCount: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> bitwidth: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">NoGlitchCounterIO</span>(bitwidth))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncFIFO</span>(<span class="params">depth: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">        <span class="comment">// write inputs</span></span><br><span class="line">        <span class="keyword">val</span> write_clock = <span class="type">Input</span>(<span class="type">Clock</span>())</span><br><span class="line">        <span class="keyword">val</span> write_enable = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">        <span class="keyword">val</span> write_data = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read inputs/outputs</span></span><br><span class="line">        <span class="keyword">val</span> read_clock = <span class="type">Input</span>(<span class="type">Clock</span>())</span><br><span class="line">        <span class="keyword">val</span> read_enable = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">        <span class="keyword">val</span> read_data = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIFO status</span></span><br><span class="line">        <span class="keyword">val</span> full = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line">        <span class="keyword">val</span> empty = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeCounter</span></span>(maxCount: <span class="type">Int</span>): <span class="type">NoGlitchCounter</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add extra bit to counter to check for fully/empty status</span></span><br><span class="line">    assert(isPow2(depth), <span class="string">&quot;AsyncFIFO needs a power-of-two depth!&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> write_counter = withClock(io.write_clock) &#123;</span><br><span class="line">        <span class="keyword">val</span> count = makeCounter(depth * <span class="number">2</span>)</span><br><span class="line">        count.io.en := io.write_enable &amp;&amp; !io.full</span><br><span class="line">        count.io.out</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> read_counter = withClock(io.read_clock) &#123;</span><br><span class="line">        <span class="keyword">val</span> count = makeCounter(depth * <span class="number">2</span>)</span><br><span class="line">        count.io.en := io.read_enable &amp;&amp; !io.empty</span><br><span class="line">        count.io.out</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// synchronize</span></span><br><span class="line">    <span class="keyword">val</span> sync = withClock(io.read_clock) &#123; <span class="type">ShiftRegister</span>(write_counter, <span class="number">2</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// status logic goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/25/Chisel_Note_11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Chisel_Note_11/" class="post-title-link" itemprop="url">Chisel学习笔记（十一）：函数式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 19:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T19:00:00+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Scala中的函数式编程"><a href="#Scala中的函数式编程" class="headerlink" title="Scala中的函数式编程"></a>Scala中的函数式编程</h2><p>函数，以多个值为输入，以单个值为输出。输入值通常叫做参数。如果函数没有输出，则返回<code>Unit</code>类型。</p>
<p>以下是函数定义的实例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的函数，可以省略去括号和返回值类型（返回值类型可以是Unit）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello1</span></span>(): <span class="type">Unit</span> = print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span> </span>= print(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Math operation: one input and one output.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">times2</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数可以有默认值，并且建议写明返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timesN</span></span>(x: <span class="type">Int</span>, n: <span class="type">Int</span> = <span class="number">2</span>) = n * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the functions listed above.</span></span><br><span class="line">hello1()    <span class="comment">// 没有参数，可以使用括号，也可以省略</span></span><br><span class="line">hello2        <span class="comment">// 调用的时候，如果原来定义时没有括号，则也不可以使用括号</span></span><br><span class="line">times2(<span class="number">4</span>)</span><br><span class="line">timesN(<span class="number">4</span>)         <span class="comment">// no need to specify n to use the default value</span></span><br><span class="line">timesN(<span class="number">4</span>, <span class="number">3</span>)      <span class="comment">// argument order is the same as the order where the function was defined</span></span><br><span class="line">timesN(n=<span class="number">7</span>, x=<span class="number">2</span>)  <span class="comment">// arguments may be reordered and assigned to explicitly</span></span><br></pre></td></tr></table></figure>

<h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p><strong>函数</strong>可以被赋值给某个<code>val</code>，并且传递给类、对象，或者作为某个参数传递给其他函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规的函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus1funct</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = x + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">times2funct</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数字面量赋值给某个Val</span></span><br><span class="line"><span class="keyword">val</span> plus1val: <span class="type">Int</span> =&gt; <span class="type">Int</span> = x =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> times2val = (x: <span class="type">Int</span>) =&gt; x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling both looks the same.</span></span><br><span class="line">plus1funct(<span class="number">4</span>)</span><br><span class="line">plus1val(<span class="number">4</span>)</span><br><span class="line">plus1funct(x=<span class="number">4</span>)</span><br><span class="line"><span class="comment">//plus1val(x=4) // 不可以这样调用</span></span><br></pre></td></tr></table></figure>

<p>为什么需要有<code>val</code>定义的函数这种操作呢？使用<code>val</code>定义函数，那么函数就和往常的变量一样，可以在各个函数之间作为参数传递。我们甚至可以自己定义高阶函数。</p>
<h3 id="定义高阶函数"><a href="#定义高阶函数" class="headerlink" title="定义高阶函数"></a>定义高阶函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义自己的函数</span></span><br><span class="line"><span class="keyword">val</span> plus1 = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> times2 = (x: <span class="type">Int</span>) =&gt; x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递给Map，在List上面调用</span></span><br><span class="line"><span class="keyword">val</span> myList = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="keyword">val</span> myListPlus = myList.map(plus1)</span><br><span class="line"><span class="keyword">val</span> myListTimes = myList.map(times2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个可以进行递归计算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">opN</span></span>(x: <span class="type">Int</span>, n: <span class="type">Int</span>, op: <span class="type">Int</span> =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123; x &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; opN(op(x), n<span class="number">-1</span>, op) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opN(<span class="number">7</span>, <span class="number">3</span>, plus1)</span><br><span class="line">opN(<span class="number">7</span>, <span class="number">3</span>, times2)</span><br></pre></td></tr></table></figure>

<p>我们注意到，定义的<code>opN</code>函数，接收一个函数参数<code>op</code>。</p>
<h3 id="函数VS对象"><a href="#函数VS对象" class="headerlink" title="函数VS对象"></a>函数VS对象</h3><p>有时候，我们会看到，使用一些不带参数的函数，会造成一定的误会。</p>
<p><strong><code>val</code>在定义的时候就已经求值，而<code>def</code>需要在调用的时候才会被求值。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x和y都是Random函数，但是x在定义的时候，其已经被求值了，而y是一个函数，每次对他进行引用的时候，都会重新求值</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="type">Random</span>.nextInt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span> </span>= <span class="type">Random</span>.nextInt</span><br><span class="line"></span><br><span class="line"><span class="comment">// x已经被求值了，所以不会再发生改变了</span></span><br><span class="line">println(<span class="string">s&quot;x = <span class="subst">$x</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;x = <span class="subst">$x</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// y的输出会和上次的不一样，因为调用的时候被重新进行了求值</span></span><br><span class="line">println(<span class="string">s&quot;y = <span class="subst">$y</span>&quot;</span>)</span><br><span class="line">println(<span class="string">s&quot;y = <span class="subst">$y</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>我们仅仅使用一次这个函数，所以这个函数可以不用赋值给<code>val</code>，当作一个字面量（如C中的常量）来进行使用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myList = <span class="type">List</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将列表中的每一个值都加1</span></span><br><span class="line">myList.map( (x:<span class="type">Int</span>) =&gt; x + <span class="number">1</span> )</span><br><span class="line">myList.map(_ + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数中可以使用case，可以进行模式匹配</span></span><br><span class="line"><span class="keyword">val</span> myAnyList = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;3&quot;</span>, <span class="number">4</span>L, myList)</span><br><span class="line">myAnyList.map &#123;</span><br><span class="line">  <span class="keyword">case</span> (_:<span class="type">Int</span>|_:<span class="type">Long</span>) =&gt; <span class="string">&quot;Number&quot;</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">&quot;String&quot;</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Chisel中的函数式编程"><a href="#Chisel中的函数式编程" class="headerlink" title="Chisel中的函数式编程"></a>Chisel中的函数式编程</h2><h3 id="实例：FIR"><a href="#实例：FIR" class="headerlink" title="实例：FIR"></a>实例：FIR</h3><p>我们可以看一个在Chisel中使用函数式编程的例子，还是以刚才的FIR为例。</p>
<p>之前的所有<code>b_i</code>全部都是以固定参数的形式传入，这次，我们传入一个能够计算参数的函数。这个计算函数以窗口长度和位宽为参数，产生一个<code>b_i</code>的参数列表。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get some math functions</span></span><br><span class="line"><span class="keyword">import</span> scala.math.&#123;abs, round, cos, <span class="type">Pi</span>, pow&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// simple triangular window</span></span><br><span class="line"><span class="comment">// 这个语法是先声明函数的类型，然后用&#x27;=’来用一个函数初始化val</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">TriangularWindow</span>: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Seq</span>[<span class="type">Int</span>] = (length, bitwidth) =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> raw_coeffs = (<span class="number">0</span> until length).map( (x:<span class="type">Int</span>) =&gt; <span class="number">1</span>-abs((x.toDouble-(length<span class="number">-1</span>)/<span class="number">2.0</span>)/((length<span class="number">-1</span>)/<span class="number">2.0</span>)) )</span><br><span class="line">  <span class="keyword">val</span> scaled_coeffs = raw_coeffs.map( (x: <span class="type">Double</span>) =&gt; round(x * pow(<span class="number">2</span>, bitwidth)).toInt)</span><br><span class="line">  scaled_coeffs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hamming window</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">HammingWindow</span>: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Seq</span>[<span class="type">Int</span>] = (length, bitwidth) =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> raw_coeffs = (<span class="number">0</span> until length).map( (x: <span class="type">Int</span>) =&gt; <span class="number">0.54</span> - <span class="number">0.46</span>*cos(<span class="number">2</span>*<span class="type">Pi</span>*x/(length<span class="number">-1</span>)))</span><br><span class="line">  <span class="keyword">val</span> scaled_coeffs = raw_coeffs.map( (x: <span class="type">Double</span>) =&gt; round(x * pow(<span class="number">2</span>, bitwidth)).toInt)</span><br><span class="line">  scaled_coeffs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以使用它来进行生成了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// our FIR has parameterized window length, IO bitwidth, and windowing function</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFir</span>(<span class="params">length: <span class="type">Int</span>, bitwidth: <span class="type">Int</span>, window: (<span class="type">Int</span>, <span class="type">Int</span></span>) <span class="title">=&gt;</span> <span class="title">Seq</span>[<span class="type">Int</span>]) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">UInt</span>(bitwidth.<span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>((bitwidth*<span class="number">2</span>+length<span class="number">-1</span>).<span class="type">W</span>)) <span class="comment">// expect bit growth, conservative but lazy</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将所有的参数转换成UInt硬件节点，宽度自动推断</span></span><br><span class="line">  <span class="keyword">val</span> coeffs = window(length, bitwidth).map(_.<span class="type">U</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意：我们不使用Vec，因为不需要按照索引访问，我们只需要在编译阶段把这些寄存器连接到正确的位置</span></span><br><span class="line">  <span class="keyword">val</span> delays = <span class="type">Seq</span>.fill(length)(<span class="type">Wire</span>(<span class="type">UInt</span>(bitwidth.<span class="type">W</span>))).scan(io.in)( (prev: <span class="type">UInt</span>, next: <span class="type">UInt</span>) =&gt; &#123;</span><br><span class="line">    next := <span class="type">RegNext</span>(prev)</span><br><span class="line">    next</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// multiply, putting result in &quot;mults&quot;</span></span><br><span class="line">  <span class="keyword">val</span> mults = delays.zip(coeffs).map&#123; <span class="keyword">case</span>(delay: <span class="type">UInt</span>, coeff: <span class="type">UInt</span>) =&gt; delay * coeff &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// add up multiplier outputs with bit growth</span></span><br><span class="line">  <span class="keyword">val</span> result = mults.reduce(_+&amp;_)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect output</span></span><br><span class="line">  io.out := result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实现和之前的简洁实现差不多，只是将连续的<code>map</code>,<code>reduce</code>操作拆分开了。</p>
<h3 id="实例：感知机"><a href="#实例：感知机" class="headerlink" title="实例：感知机"></a>实例：感知机</h3><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200825221618486.png" alt="image-20200825221618486"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Neuron</span>(<span class="params">inputs: <span class="type">Int</span>, act: <span class="type">FixedPoint</span> =&gt; <span class="type">FixedPoint</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in      = <span class="type">Input</span>(<span class="type">Vec</span>(inputs, <span class="type">FixedPoint</span>(<span class="number">16.</span><span class="type">W</span>, <span class="number">8.</span><span class="type">BP</span>)))</span><br><span class="line">    <span class="keyword">val</span> weights = <span class="type">Input</span>(<span class="type">Vec</span>(inputs, <span class="type">FixedPoint</span>(<span class="number">16.</span><span class="type">W</span>, <span class="number">8.</span><span class="type">BP</span>)))</span><br><span class="line">    <span class="keyword">val</span> out     = <span class="type">Output</span>(<span class="type">FixedPoint</span>(<span class="number">16.</span><span class="type">W</span>, <span class="number">8.</span><span class="type">BP</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  io.out := ( io.in zip io.weights ).map( <span class="keyword">case</span>(a,b) =&gt; a*b ).reduce(_+_)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/25/Chisel_Note_10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Chisel_Note_10/" class="post-title-link" itemprop="url">Chisel学习笔记（十）：高阶函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 17:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T17:00:00+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们在前面的代码中，经常使用到<code>for</code>循环，显然过于冗长，并且和函数式编程的宗旨相悖。</p>
<p>在本节中，我们以之前实现的FIR滤波器为例，通过Scala的特性进行重构。</p>
<h2 id="回顾：FIR滤波器"><a href="#回顾：FIR滤波器" class="headerlink" title="回顾：FIR滤波器"></a>回顾：FIR滤波器</h2><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200825135235362.png" alt="image-20200825135235362"></p>
<p>$$ y[n] = b_0x[n]+b_1x[n-1]+b_2x[n-2]+\cdots$$</p>
<h3 id="之前的实现"><a href="#之前的实现" class="headerlink" title="之前的实现"></a>之前的实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManyDynamicElementVecFir</span>(<span class="params">length: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> consts = <span class="type">Input</span>(<span class="type">Vec</span>(length, <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reference solution</span></span><br><span class="line">  <span class="keyword">val</span> regs = <span class="type">RegInit</span>(<span class="type">VecInit</span>(<span class="type">Seq</span>.fill(length - <span class="number">1</span>)(<span class="number">0.</span><span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>))))</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) regs(i) := io.in</span><br><span class="line">      <span class="keyword">else</span>       regs(i) := regs(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> muls = <span class="type">Wire</span>(<span class="type">Vec</span>(length, <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) muls(i) := io.in * io.consts(i)</span><br><span class="line">      <span class="keyword">else</span>       muls(i) := regs(i - <span class="number">1</span>) * io.consts(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> scan = <span class="type">Wire</span>(<span class="type">Vec</span>(length, <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) scan(i) := muls(i)</span><br><span class="line">      <span class="keyword">else</span> scan(i) := muls(i) + scan(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  io.out := scan(length - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾我们的实现：</p>
<ul>
<li>对于每一个<code>regs(i)</code>，和其对应的<code>io.const</code>相乘，并且存储到<code>muls</code>向量中。</li>
<li>对于每一个<code>muls(i)</code>，<code>scan(0) = muls(0)</code>, <code>scan(1) = scan(0) + muls(1) = muls(0) + muls(1)</code>……</li>
<li>取出<code>scan</code>中的最后一个元素，并且赋值给<code>io.out</code></li>
</ul>
<p>事实上，我们可以使用一个更简单的方法实现。</p>
<h3 id="更简单的实现"><a href="#更简单的实现" class="headerlink" title="更简单的实现"></a>更简单的实现</h3><p>前方高能。</p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManyDynamicElementVecFir</span>(<span class="params">length: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> consts = <span class="type">Input</span>(<span class="type">Vec</span>(length, <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">  &#125;)</span><br><span class="line">  io.out := (taps zip io.consts).map &#123; <span class="keyword">case</span> (a, b) =&gt; a * b &#125;.reduce(_ + _)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 就这？就这？？？？？？你在逗我？？？？？？？？？？</p>
</blockquote>
<p>让我们来解析一下这个代码。</p>
<ul>
<li><p><code>(taps zip io.consts)</code> 的输入是两个List： <code>taps</code> 和 <code>io.consts</code>，这个函数最终返回的是一个列表，其中的元素是二元组，两个数组相同下标的元素被组合成一个二元组。最终，列表会长这样：<code>[(taps(0), io.consts(0)), (taps(1), io.consts(1)), ..., (taps(n), io.consts(n))]</code>。注意：在Scala中，由于对于仅有一个参数的方法，其调用可以省略<code>.</code>和<code>()</code>，所以这个等效于<code>(taps.zip(io.consts))</code>。</p>
</li>
<li><p><code>.map &#123; case (a, b) =&gt; a * b &#125;</code> 在列表中的每一个函数上面都应用了一个匿名函数，并返回如此操作之后的列表。这个匿名函数的输入是一个元组<code>(a,b)</code>，函数输出是<code>a*b</code>。最终，返回的列表是 <code>[taps(0) * io.consts(0), taps(1) * io.consts(1), ..., taps(n) * io.consts(n)]</code>。</p>
</li>
<li><p>最终, <code>.reduce(_ + _)</code> 也对列表进行了操作。这个函数拥有两个参数：</p>
<ul>
<li><p>当前的累加和</p>
</li>
<li><p>当前处理到的元素</p>
<p>最终返回的结果应当是 <code>(((muls(0) + muls(1)) + muls(2)) + ...) + muls(n)</code>，最深层的括号是最先被计算的。这就是<code>reduce</code>模型。</p>
</li>
</ul>
</li>
</ul>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>在我们上面所见的<code>map</code>和<code>reduce</code>被称为<strong>高阶函数</strong>。为什么称之为高阶函数？因为他们输入的参数是<strong>函数</strong>。</p>
<p>函数式编程的一个好处是，我们不必聚焦于控制相关的代码，而是可以专注于编写逻辑。</p>
<h3 id="声明匿名函数的不同方法"><a href="#声明匿名函数的不同方法" class="headerlink" title="声明匿名函数的不同方法"></a>声明匿名函数的不同方法</h3><ul>
<li>对于那些<strong>每个参数都仅仅被使用过一次</strong>的函数，可以使用下划线(<code>_</code>)来引用每一个参数。在上面的例子中，<code>reduce</code>的就是拥有两个参数，可以被写作是<code>_+_</code>，代表第一个参数加第二个参数</li>
<li>也可以显式地声明那些输入参数，例如，上面的函数可以写成是<code>(a,b) =&gt; a + b</code>。将参数列表放在括号中，后接一个<code>=&gt;</code>，然后是函数体。</li>
<li>当需要对元组进行解包的时候，需要使用<code>case</code>语句。<code>case (a,b) =&gt; a * b</code></li>
</ul>
<h3 id="在Scala中的实践"><a href="#在Scala中的实践" class="headerlink" title="在Scala中的实践"></a>在Scala中的实践</h3><h4 id="Map函数"><a href="#Map函数" class="headerlink" title="Map函数"></a>Map函数</h4><p><code>List[A].map</code>的定义是<code>map[B](f: (A)=&gt;B)):List[B]</code>。定义看起来略微有点复杂，我们先将<code>A</code>认为是<code>Int</code>（软件类型），<code>B</code>认为是<code>UInt</code>（硬件类型）。</p>
<p>上面的声明可以看作是：<code>map</code>函数接收一个输入类型为<code>A</code>，返回类型为<code>B</code>的函数，并且返回一个元素类型为<code>B</code>的列表。</p>
<h4 id="zipWithIndex函数"><a href="#zipWithIndex函数" class="headerlink" title="zipWithIndex函数"></a>zipWithIndex函数</h4><p><code>List.zipWithIndex</code>的定义是<code>zipWithIndex: List[(A, Int)]</code>。</p>
<p><code>List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;).zipWithIndex</code>将返回<code>List((&quot;a&quot;, 0), (&quot;b&quot;, 1), (&quot;c&quot;, 2), (&quot;d&quot;, 3))</code>。</p>
<h4 id="Reduce函数"><a href="#Reduce函数" class="headerlink" title="Reduce函数"></a>Reduce函数</h4><p><code>List[A].reduce</code>的定义是<code>reduce(op: (A, A) ⇒ A): A</code>。</p>
<p>事实上，<code>A</code>只需要是子类就可以了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce((a, b) =&gt; a + b))  <span class="comment">// returns the sum of all the elements</span></span><br><span class="line">println(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(_ * _))  <span class="comment">// returns the product of all the elements</span></span><br><span class="line">println(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).map(_ + <span class="number">1</span>).reduce(_ + _))  <span class="comment">// you can chain reduce onto the result of a map</span></span><br></pre></td></tr></table></figure>

<h4 id="Fold函数"><a href="#Fold函数" class="headerlink" title="Fold函数"></a>Fold函数</h4><p><code>fold</code>函数和<code>reduce</code>函数非常类似，有一点不同的是，<code>fold</code>函数对于迭代具有初始值，可以从<code>fold</code>函数的定义中看出： <code>fold(z: A)(op: (A, A) ⇒ A): A</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).fold(<span class="number">0</span>)(_ + _))  <span class="comment">// equivalent to the sum using reduce</span></span><br><span class="line">println(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).fold(<span class="number">1</span>)(_ + _))  <span class="comment">// like above, but accumulation starts at 1</span></span><br><span class="line">println(<span class="type">List</span>().fold(<span class="number">1</span>)(_ + _))  <span class="comment">// unlike reduce, does not fail on an empty input</span></span><br></pre></td></tr></table></figure>

<h2 id="高阶函数应用实例：仲裁器"><a href="#高阶函数应用实例：仲裁器" class="headerlink" title="高阶函数应用实例：仲裁器"></a>高阶函数应用实例：仲裁器</h2><p>我们将构建一个仲裁器，拥有<code>n</code>个输入和1个输出，选择编号最小的有效输出。</p>
<p>这个例子需要一定的时间消化。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRoutingArbiter</span>(<span class="params">numChannels: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Vec</span>(<span class="type">Flipped</span>(<span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))), numChannels)</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">  &#125; )</span><br><span class="line"></span><br><span class="line">  io.out.valid := io.in.map(_.valid).reduce(_ || _)        <span class="comment">// 取出Valid位，并将所有的Valid或起来</span></span><br><span class="line">  <span class="keyword">val</span> channel = <span class="type">PriorityMux</span>(</span><br><span class="line">    io.in.map(_.valid).zipWithIndex.map &#123; <span class="keyword">case</span> (valid, index) =&gt; (valid, index.<span class="type">U</span>) &#125;</span><br><span class="line">  )</span><br><span class="line">  io.out.bits := io.in(channel).bits                    <span class="comment">// 将编码好的进行选择</span></span><br><span class="line">  io.in.map(_.ready).zipWithIndex.foreach &#123; <span class="keyword">case</span> (ready, index) =&gt;</span><br><span class="line">    ready := io.out.ready &amp;&amp; channel === index.<span class="type">U</span>        <span class="comment">// 被选中的就Ready</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PriorityMux(List[Bool, Bits])</code>，按照Index从低到高，选中第一个有效的，其实是一个优先编码+多路选择。</p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.out.valid := io.in.map(_.valid).reduce(_ || _)</span><br></pre></td></tr></table></figure>

<p><code>io.in.map(_.valid)</code>将输入中所有的Valid取出，组成一个新的向量。</p>
<p><code>.reduce(_ || _)</code>将向量中所有的Bit都或在一起。</p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.in.map(_.valid).zipWithIndex.map &#123; <span class="keyword">case</span> (valid, index) =&gt; (valid, index.<span class="type">U</span>) &#125;</span><br></pre></td></tr></table></figure>

<p><code>io.in.map(_.valid).zipWithIndex</code>将每一项都和他的Index串联在一起。</p>
<p><code>.map &#123; case (valid, index) =&gt; (valid, index.U) &#125;</code>将<code>index</code>转换为硬件信号，因为Mux的输出是硬件信号，同时<code>Vec</code>也需要硬件信号做索引。</p>
<hr>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.in.map(_.ready).zipWithIndex.foreach &#123; <span class="keyword">case</span> (ready, index) =&gt;</span><br><span class="line">    ready := io.out.ready &amp;&amp; channel === index.<span class="type">U</span>        <span class="comment">// 被选中的就Ready</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意：此处虽然定义了新的函数，<code>case(ready, index) =&gt; </code>，但是传入的仍然是原来的硬件节点，也就是说，传入函数的硬件节点不会被重复的创建，相当于传递的是引用。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/25/Chisel_Note_9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Chisel_Note_9/" class="post-title-link" itemprop="url">Chisel学习笔记（九）：容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 15:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T15:00:00+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在这个模块中，我们将使用Chisel容器作为硬件的生成器。</p>
<h2 id="背景：FIR滤波器"><a href="#背景：FIR滤波器" class="headerlink" title="背景：FIR滤波器"></a>背景：FIR滤波器</h2><p>我们首先来了解一下FIR滤波器：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200825135235362.png" alt="image-20200825135235362"></p>
<p>对于FIR滤波器的输出，我们这样定义：</p>
<p>$$ y[n] = b_0x[n]+b_1x[n-1]+b_2x[n-2]+\cdots$$</p>
<p>其中，</p>
<ul>
<li>$y[n]$是在第$n$时刻的输出信号</li>
<li>$x[n]$是输入信号</li>
<li>$b_i$是滤波器的参数，或脉冲反馈</li>
<li>$x[n-1]$是上个周期的$x[n]$，以此类推。</li>
</ul>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>对于上图出现的滤波器，我们可以简单的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIR_4</span>(<span class="params">b0: <span class="type">Int</span>, b1: <span class="type">Int</span>, b2: <span class="type">Int</span>, b3: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> x_n1 = <span class="type">RegNext</span>(io.in, <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line">    <span class="keyword">val</span> x_n2 = <span class="type">RegNext</span>(x_n1, <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line">    <span class="keyword">val</span> x_n3 = <span class="type">RegNext</span>(x_n2, <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line">    io.out := io.in * b0.<span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>) + </span><br><span class="line">        x_n1 * b1.<span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>) +</span><br><span class="line">        x_n2 * b2.<span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>) + </span><br><span class="line">        x_n3 * b3.<span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数化实现与验证"><a href="#参数化实现与验证" class="headerlink" title="参数化实现与验证"></a>参数化实现与验证</h2><p>如果我们想要引入更多的状态，例如，在上面的例子中，我们如果需要做到让FIR的Taps数量可以参数化，应该怎么实现呢？</p>
<ul>
<li>首先，使用软件建立一个可以用于仿真的模型</li>
<li>其次，重新设计这个硬件，通过刚刚的仿真确定是否正常工作</li>
</ul>
<h3 id="软件实现的Golden-Model"><a href="#软件实现的Golden-Model" class="headerlink" title="软件实现的Golden Model"></a>软件实现的Golden Model</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * A naive implementation of an FIR filter with an arbitrary number of taps.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaFirFilter</span>(<span class="params">taps: <span class="type">Seq</span>[<span class="type">Int</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pseudoRegisters = <span class="type">List</span>.fill(taps.length)(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">poke</span></span>(value: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    pseudoRegisters = value :: pseudoRegisters.take(taps.length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">var</span> accumulator = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(i &lt;- taps.indices) &#123;</span><br><span class="line">      accumulator += taps(i) * pseudoRegisters(i)</span><br><span class="line">    &#125;</span><br><span class="line">    accumulator</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了一个Var来记录上图中的X寄存器阵列。</p>
<p>对于Poke方法，我们也对其进行了相应的重写，以模拟硬件的行为。</p>
<p>此处需要注意的是，<code>value :: pseudoRegisters.take(taps.length - 1)</code>表示将某个值追加到列表的头部。</p>
<h3 id="使用容器实现"><a href="#使用容器实现" class="headerlink" title="使用容器实现"></a>使用容器实现</h3><p>此处发生了一系列的改动：</p>
<ul>
<li>输入的常量从<code>b0,b1,b2</code>变成了一个整数序列</li>
<li>宽度也可以定制了：<code>bitWidth</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManyElementFir</span>(<span class="params">consts: <span class="type">Seq</span>[<span class="type">Int</span>], bitWidth: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">UInt</span>(bitWidth.<span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(bitWidth.<span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 注意到这是Mutable的，也就是可变的</span></span><br><span class="line">  <span class="keyword">val</span> regs = mutable.<span class="type">ArrayBuffer</span>[<span class="type">UInt</span>]()</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until consts.length) &#123;</span><br><span class="line">      <span class="comment">// 寄存器阵列，除了第一个是直接采样输入，其他的都是前几个时刻的输入</span></span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) regs += io.in</span><br><span class="line">      <span class="keyword">else</span>       regs += <span class="type">RegNext</span>(regs(i - <span class="number">1</span>), <span class="number">0.</span><span class="type">U</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 做完乘法的结果</span></span><br><span class="line">  <span class="keyword">val</span> muls = mutable.<span class="type">ArrayBuffer</span>[<span class="type">UInt</span>]()</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until consts.length) &#123;</span><br><span class="line">      muls += regs(i) * consts(i).<span class="type">U</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">val</span> scan = mutable.<span class="type">ArrayBuffer</span>[<span class="type">UInt</span>]()</span><br><span class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until consts.length) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) scan += muls(i)</span><br><span class="line">      <span class="keyword">else</span> scan += muls(i) + scan(i - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  io.out := scan.last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h4><p>代码中存在三个并行块，分别使用了Scala的容器 <code>ArrayBuffer</code>。 <code>ArrayBuffer</code> 可以使用 <code>+=</code> 往后追加元素。</p>
<p>在第一个块中，我们创建了一个<code>regs</code> 的<code>ArrayBuffer</code>，其中的元素是<code>UInt</code>，注意，这个集合仅仅包含硬件的输出（寄存器、组合逻辑的输出），而不包含实际的寄存器。创建的寄存器<code>RegNext</code>，是匿名的硬件节点。</p>
<blockquote>
<p> 这里跟<code>Vec</code>是不一样的，我们是否可以通过其访问某个硬件呢？</p>
</blockquote>
<h2 id="实例：RISC寄存器堆"><a href="#实例：RISC寄存器堆" class="headerlink" title="实例：RISC寄存器堆"></a>实例：RISC寄存器堆</h2><p>不多说，再熟悉不过了吧。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterFile</span>(<span class="params">readPorts: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    require(readPorts &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> wen   = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">        <span class="keyword">val</span> waddr = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">5.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> wdata = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> raddr = <span class="type">Input</span>(<span class="type">Vec</span>(readPorts, <span class="type">UInt</span>(<span class="number">5.</span><span class="type">W</span>)))</span><br><span class="line">        <span class="keyword">val</span> rdata = <span class="type">Output</span>(<span class="type">Vec</span>(readPorts, <span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>)))</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// A Register of a vector of UInts</span></span><br><span class="line">    <span class="keyword">val</span> reg = <span class="type">RegInit</span>(<span class="type">VecInit</span>(<span class="type">Seq</span>.fill(<span class="number">32</span>)(<span class="number">0.</span><span class="type">U</span>(<span class="number">32.</span><span class="type">W</span>))))</span><br><span class="line">    when (io.wen) &#123;</span><br><span class="line">        reg(io.waddr) := io.wdata</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until readPorts) &#123;</span><br><span class="line">        when (io.raddr(i) === <span class="number">0.</span><span class="type">U</span>) &#123;</span><br><span class="line">            io.rdata(i) := <span class="number">0.</span><span class="type">U</span></span><br><span class="line">        &#125; .otherwise &#123;</span><br><span class="line">            io.rdata(i) := reg(io.raddr(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用生成器的方法实现"><a href="#使用生成器的方法实现" class="headerlink" title="使用生成器的方法实现"></a>使用生成器的方法实现</h2><p>另一种实现方法，我们将在后面讨论。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManyDynamicElementVecFir</span>(<span class="params">length: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> valid = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> consts = <span class="type">Input</span>(<span class="type">Vec</span>(length, <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Such concision! You&#x27;ll learn what all this means later.</span></span><br><span class="line">  <span class="keyword">val</span> taps = <span class="type">Seq</span>(io.in) ++ <span class="type">Seq</span>.fill(io.consts.length - <span class="number">1</span>)(<span class="type">RegInit</span>(<span class="number">0.</span><span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">  taps.zip(taps.tail).foreach &#123; <span class="keyword">case</span> (a, b) =&gt; when (io.valid) &#123; b := a &#125; &#125;</span><br><span class="line"></span><br><span class="line">  io.out := taps.zip(io.consts).map &#123; <span class="keyword">case</span> (a, b) =&gt; a * b &#125;.reduce(_ + _)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/25/Chisel_Note_8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/Chisel_Note_8/" class="post-title-link" itemprop="url">Chisel学习笔记（八）：Chisel标准库实例</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 13:00:00" itemprop="dateCreated datePublished" datetime="2020-08-25T13:00:00+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Chisel提供了大量的标准接口，并且可以为我们提供可复用的硬件模块。</p>
<h2 id="Decoupled-标准Ready-Valid接口"><a href="#Decoupled-标准Ready-Valid接口" class="headerlink" title="Decoupled: 标准Ready-Valid接口"></a>Decoupled: 标准Ready-Valid接口</h2><p><code>DecoupledIO</code>是Chisel提供的一个标准接口，它提供了一个用于数据传输的Ready-Valid界面。</p>
<ul>
<li>发送方（数据源）：控制<code>bits</code>和<code>valid</code></li>
<li>接收方：控制<code>ready</code>，当其准备好接收数据的时候，拉高<code>ready</code></li>
</ul>
<p>这个接口提供了一个双向流控机制，也可以做到接收方反压发送方的效果。</p>
<p>注意：<code>ready</code>和<code>valid</code>信号不应该组合地依赖于对方，否则会导致组合逻辑环路。<code>ready</code>仅仅应当依赖于接收方是否准备好接收数据，<code>valid</code>应当仅仅依赖于发送方是否已经准备好数据。当传输完成后，<code>ready</code>和<code>valid</code>信号才允许变化。</p>
<p>Chisel提供了一个<code>DecoupledIO</code>接口。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myChiselData = <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)</span><br><span class="line"><span class="keyword">val</span> myDecoupled = <span class="type">Decoupled</span>(myChiselData)</span><br></pre></td></tr></table></figure>

<h3 id="实例：队列"><a href="#实例：队列" class="headerlink" title="实例：队列"></a>实例：队列</h3><p>Chisel提供了队列，一个标准的Ready-Valid接口模型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Driver</span>(() =&gt; <span class="keyword">new</span> <span class="type">Module</span> &#123;</span><br><span class="line">    <span class="comment">// Example circuit using a Queue</span></span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> in = <span class="type">Flipped</span>(<span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">      <span class="keyword">val</span> out = <span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> queue = <span class="type">Queue</span>(io.in, <span class="number">2</span>)  <span class="comment">// 2-element queue</span></span><br><span class="line">    io.out &lt;&gt; queue</span><br><span class="line">  &#125;) &#123; c =&gt; <span class="keyword">new</span> <span class="type">PeekPokeTester</span>(c) &#123;</span><br><span class="line">    <span class="comment">// Example testsequence showing the use and behavior of Queue</span></span><br><span class="line">    poke(c.io.out.ready, <span class="number">0</span>)</span><br><span class="line">    poke(c.io.in.valid, <span class="number">1</span>)  <span class="comment">// Enqueue an element</span></span><br><span class="line">    poke(c.io.in.bits, <span class="number">42</span>)</span><br><span class="line">    println(<span class="string">s&quot;Starting:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.in: ready=<span class="subst">$&#123;peek(c.io.in.ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.out: valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// in.Ready:1, out.Valid: 0</span></span><br><span class="line">    step(<span class="number">1</span>)</span><br><span class="line">      </span><br><span class="line">    poke(c.io.in.valid, <span class="number">1</span>)  <span class="comment">// Enqueue another element</span></span><br><span class="line">    poke(c.io.in.bits, <span class="number">43</span>)</span><br><span class="line">    <span class="comment">// What do you think io.out.valid and io.out.bits will be?</span></span><br><span class="line">    println(<span class="string">s&quot;After first enqueue:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.in: ready=<span class="subst">$&#123;peek(c.io.in.ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.out: valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    step(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// in.Ready:1, out.Valid:1</span></span><br><span class="line">    </span><br><span class="line">    poke(c.io.in.valid, <span class="number">1</span>)  <span class="comment">// Read a element, attempt to enqueue</span></span><br><span class="line">    poke(c.io.in.bits, <span class="number">44</span>)</span><br><span class="line">    poke(c.io.out.ready, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// What do you think io.in.ready will be, and will this enqueue succeed, and what will be read?</span></span><br><span class="line">    println(<span class="string">s&quot;On first read:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.in: ready=<span class="subst">$&#123;peek(c.io.in.ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.out: valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    step(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// in.Ready:0, out.Valid:1</span></span><br><span class="line">  </span><br><span class="line">    poke(c.io.in.valid, <span class="number">0</span>)  <span class="comment">// Read elements out</span></span><br><span class="line">    poke(c.io.out.ready, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// What do you think will be read here?</span></span><br><span class="line">    println(<span class="string">s&quot;On second read:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.in: ready=<span class="subst">$&#123;peek(c.io.in.ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.out: valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    step(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// in.Ready:1, out.Valid:1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Will a third read produce anything?</span></span><br><span class="line">    println(<span class="string">s&quot;On third read:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.in: ready=<span class="subst">$&#123;peek(c.io.in.ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tio.out: valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// in.Ready:1, out.Valid:0</span></span><br><span class="line">    step(<span class="number">1</span>)</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例：仲裁器"><a href="#实例：仲裁器" class="headerlink" title="实例：仲裁器"></a>实例：仲裁器</h3><p>根据预先设定好的优先级，仲裁器将数据从<code>DecoupledIO</code>源路由到<code>DecoupledIO</code>目的。</p>
<p>仲裁器分为</p>
<ul>
<li>普通仲裁器：优先允许Index较低的请求</li>
<li>轮询仲裁器：轮询各个请求，优先级相等</li>
</ul>
<p><strong>发起请求的时候，是拉高<code>Valid</code>信号，而请求被满足的时候，接收方会拉高<code>Ready</code>信号。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Driver</span>(() =&gt; <span class="keyword">new</span> <span class="type">Module</span> &#123;</span><br><span class="line">    <span class="comment">// Example circuit using a priority arbiter</span></span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> in = <span class="type">Flipped</span>(<span class="type">Vec</span>(<span class="number">2</span>, <span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))))</span><br><span class="line">      <span class="keyword">val</span> out = <span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// Arbiter doesn&#x27;t have a convenience constructor, so it&#x27;s built like any Module</span></span><br><span class="line">    <span class="keyword">val</span> arbiter = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">Arbiter</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>), <span class="number">2</span>))  <span class="comment">// 2 to 1 Priority Arbiter</span></span><br><span class="line">    arbiter.io.in &lt;&gt; io.in</span><br><span class="line">    io.out &lt;&gt; arbiter.io.out</span><br><span class="line">  &#125;) &#123; c =&gt; <span class="keyword">new</span> <span class="type">PeekPokeTester</span>(c) &#123;</span><br><span class="line">    poke(c.io.in(<span class="number">0</span>).valid, <span class="number">0</span>)</span><br><span class="line">    poke(c.io.in(<span class="number">1</span>).valid, <span class="number">0</span>)</span><br><span class="line">    println(<span class="string">s&quot;Start:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tin(0).ready=<span class="subst">$&#123;peek(c.io.in(0).ready)&#125;</span>, in(1).ready=<span class="subst">$&#123;peek(c.io.in(1).ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tout.valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, out.bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    poke(c.io.in(<span class="number">1</span>).valid, <span class="number">1</span>)  <span class="comment">// Valid input 1</span></span><br><span class="line">    poke(c.io.in(<span class="number">1</span>).bits, <span class="number">42</span>)</span><br><span class="line">    <span class="comment">// What do you think the output will be?</span></span><br><span class="line">    println(<span class="string">s&quot;valid input 1:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tin(0).ready=<span class="subst">$&#123;peek(c.io.in(0).ready)&#125;</span>, in(1).ready=<span class="subst">$&#123;peek(c.io.in(1).ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tout.valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, out.bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    poke(c.io.in(<span class="number">0</span>).valid, <span class="number">1</span>)  <span class="comment">// Valid inputs 0 and 1</span></span><br><span class="line">    poke(c.io.in(<span class="number">0</span>).bits, <span class="number">43</span>)</span><br><span class="line">    <span class="comment">// What do you think the output will be? Which inputs will be ready?</span></span><br><span class="line">    println(<span class="string">s&quot;valid inputs 0 and 1:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tin(0).ready=<span class="subst">$&#123;peek(c.io.in(0).ready)&#125;</span>, in(1).ready=<span class="subst">$&#123;peek(c.io.in(1).ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tout.valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, out.bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">    poke(c.io.in(<span class="number">1</span>).valid, <span class="number">0</span>)  <span class="comment">// Valid input 0</span></span><br><span class="line">    <span class="comment">// What do you think the output will be?</span></span><br><span class="line">    println(<span class="string">s&quot;valid input 0:&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tin(0).ready=<span class="subst">$&#123;peek(c.io.in(0).ready)&#125;</span>, in(1).ready=<span class="subst">$&#123;peek(c.io.in(1).ready)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">s&quot;\tout.valid=<span class="subst">$&#123;peek(c.io.out.valid)&#125;</span>, out.bits=<span class="subst">$&#123;peek(c.io.out.bits)&#125;</span>&quot;</span>)</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h2><h3 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h3><h4 id="PopCount"><a href="#PopCount" class="headerlink" title="PopCount"></a>PopCount</h4><p>PopCount对某个向量中的1的个数进行计数。</p>
<h4 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h4><p>反转输入的向量。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>计数器每个周期加1.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counter = <span class="type">Counter</span>(<span class="number">3</span>)  <span class="comment">// 3-count Counter (outputs range [0...2])</span></span><br><span class="line">when(io.count) &#123;</span><br><span class="line">    counter.inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余的函数可以参见CheetSheet。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/24/RV_Note_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/RV_Note_1/" class="post-title-link" itemprop="url">RISC-V学习笔记（一）：RV32/64及Zicsr</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-24 14:00:00" itemprop="dateCreated datePublished" datetime="2020-08-24T14:00:00+08:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="RV32I指令集基础"><a href="#RV32I指令集基础" class="headerlink" title="RV32I指令集基础"></a>RV32I指令集基础</h2><p>对于RV32I而言，有4种核心的指令类型（R/I/S/U）。所有的32位的指令必须在内存中四字对齐。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200826195432860.png" alt="image-20200826195432860"></p>
<ul>
<li><strong>地址未对齐异常将被确定要跳转的跳转指令或无条件跳转指令所报告，而不是被目标指令报告，这一点和MIPS不同。不跳转的指令不会报告地址未对齐异常。</strong></li>
<li>对于保留指令，并不指明其行为，不会触发异常。<strong>这一点和MIPS不同。</strong>在实现中，我们可以直接Invalidate这条指令。</li>
<li>除了CSR指令，其他的指令的立即数全部都会做符号扩展</li>
<li>符号位总是在指令的第31位，为了简化电路的逻辑</li>
</ul>
<h3 id="立即数的编码"><a href="#立即数的编码" class="headerlink" title="立即数的编码"></a>立即数的编码</h3><p>若考虑立即数编码，严格来说，指令类型应该分为以下几种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200826195653448.png" alt="image-20200826195653448"></p>
<hr>
<p>从另一个角度看，各类指令编码出的立即数如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828220320504.png" alt="image-20200828220320504"></p>
<p>我们可以看到，符号扩展总是使用的第31位。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="整数运算指令"><a href="#整数运算指令" class="headerlink" title="整数运算指令"></a>整数运算指令</h3><ul>
<li>整数运算指令不造成任何异常，因为结果溢出的异常通常是可以使用软件机制来进行检测的 </li>
</ul>
<h4 id="寄存器-立即数指令"><a href="#寄存器-立即数指令" class="headerlink" title="寄存器-立即数指令"></a>寄存器-立即数指令</h4><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828220855474.png" alt="image-20200828220855474"></p>
<ul>
<li><p><code>ADDI</code>将符号扩展的12位立即数加到<code>rs1</code>，并且会忽略溢出。</p>
</li>
<li><p><code>SLTI</code>在<code>rs1</code>小于<strong>符号扩展后</strong>的立即数时，将<code>rd</code>设置为1.</p>
</li>
<li><p><code>SLITU</code>还是做的<strong>符号扩展</strong>，只是之后做的<strong>无符号比较</strong></p>
</li>
<li><p><code>ANDI/ORI/XORI</code>还是做的符号扩展，然后进行相应的逻辑运算</p>
</li>
</ul>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828221627196.png" alt="image-20200828221627196"></p>
<ul>
<li><code>rs1</code>存放要被移位的操作数</li>
<li>需要被移动的位数在低5位的<code>IMM</code>中<strong>（注意RV64I不一样！）</strong></li>
<li><code>30</code>位表示右移的类型</li>
<li>SLLI: 逻辑左移（填0）</li>
<li>SRLI: 逻辑右移（填0）</li>
<li>SRAI：算术左移（填符号位）</li>
</ul>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829124013137.png" alt="image-20200829124013137"></p>
<ul>
<li>LUI: 不对称的立即数载入，将<code>imm</code>载入<code>rd</code>的高20位，低12位填0.</li>
<li>AUIPC: 将当前的PC和<code>imm[31:12], 12&#39;b0</code>相加，结果存入<code>rd</code></li>
</ul>
<h4 id="寄存器-寄存器指令"><a href="#寄存器-寄存器指令" class="headerlink" title="寄存器-寄存器指令"></a>寄存器-寄存器指令</h4><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829124031748.png" alt="image-20200829124031748"></p>
<ul>
<li>比较简单，不解释了</li>
</ul>
<h4 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h4><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829124049028.png" alt="image-20200829124049028"></p>
<ul>
<li>NOP === ADDI x0,x0,0</li>
</ul>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><ul>
<li>RV32I提供了两种控制转移指令：无条件跳转和条件分支。<strong>没有延迟槽</strong>。</li>
<li>如果指令访问异常或缺页异常，则会在目标指令汇报异常，而不是那条跳转指令</li>
</ul>
<h4 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h4><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828232145570.png" alt="image-20200828232145570"></p>
<ul>
<li><p>偏移量被符号扩展，并且加到跳转指令的PC上，获得跳转目标地址。</p>
</li>
<li><p><code>JAL</code>将跳转指令的<code>pc+4</code>存入到<code>rd</code>寄存器里面。</p>
</li>
<li><p>J指令被编码为<code>JAL x0</code>，也就是说不写入寄存器</p>
</li>
</ul>
<hr>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828232427713.png" alt="image-20200828232427713"></p>
<ul>
<li><p><code>JALR</code>是间接转移指令，目标地址是<code>rs1</code>加上符号扩展的12位的立即数，最后把目标的最低位置0，然后将<code>pc+4</code>写入<code>rd</code>。</p>
</li>
<li><p>如果不需要保存返回地址，直接把<code>rd</code>设置成0就可以了。</p>
</li>
<li><p><strong>JAL和JALR指令会产生地址未对齐异常</strong></p>
</li>
</ul>
<hr>
<p><strong>关于RAS</strong></p>
<p>RISC-V规定，<code>JAL</code>仅在<code>rd=x1/x5</code>的时候将地址放入RAS中，其余时刻不做操作。</p>
<p><code>JALR</code>的操作遵循下表，<code>link</code>在寄存器是<code>x1</code>或<code>x5</code>的时候为真：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828234854720.png" alt="image-20200828234854720"></p>
<h4 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h4><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200828235706431.png" alt="image-20200828235706431"></p>
<ul>
<li>所有的条件转移指令使用B类指令编码</li>
<li>偏移量在符号扩展之后，和当前指令的PC相加</li>
<li>在预测的时候，应当在第一次预测时，猜测往后会跳转，往前不跳转。</li>
<li>无条件转移在RV中永远都是JAL，不会使用那些条件永远为真的无条件转移指令，例如MIPS中的x0,x0</li>
<li>只有在跳转的时候，才有可能生成地址未对齐异常</li>
</ul>
<h3 id="Load-Store"><a href="#Load-Store" class="headerlink" title="Load/Store"></a>Load/Store</h3><p>EEI会定义地址空间的哪些部分可以被指令读取，哪些部分只能以字读取等待。</p>
<p><strong>如果Load指令的目的地址是<code>x0</code>，则必须要造成异常！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829000716160.png" alt="image-20200829000716160"></p>
<ul>
<li><p>Load属于I类指令，Store属于S类指令。</p>
</li>
<li><p>地址没有对齐，将造成的行为取决于EEI的定义。</p>
</li>
<li><p>我们定义，地址未对齐，将造成异常。</p>
</li>
</ul>
<h3 id="ECALL和断点"><a href="#ECALL和断点" class="headerlink" title="ECALL和断点"></a>ECALL和断点</h3><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829002351701.png" alt="image-20200829002351701"></p>
<h2 id="RV64I指令集"><a href="#RV64I指令集" class="headerlink" title="RV64I指令集"></a>RV64I指令集</h2><ul>
<li>RV64I指令集在上面RV32的基础上，将寄存器宽度拓展到了64位。</li>
<li>在RV64I中，多出了一些<code>*W</code>指令，这些指令忽略操作数的高32位，并且总是输出32位有符号数，并符号扩展到64位。也就是说，从<code>XLEN-1</code>到<code>31</code>位都是一样的。</li>
<li>注意RV64I中的移位指令，其<code>shamt</code>域多了1位</li>
<li>对于LUI而言，是将原来32位的结果扩展到了64位，AUIPC也是如此</li>
</ul>
<h2 id="Zicsr控制指令"><a href="#Zicsr控制指令" class="headerlink" title="Zicsr控制指令"></a>Zicsr控制指令</h2><p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200829125633184.png" alt="image-20200829125633184"></p>
<ul>
<li>所有的CSR指令<strong>原子地</strong>读、改写单个CSR寄存器。</li>
<li>CSR寄存器被编码到上面的<code>csr</code>域中，<code>31-20</code>位</li>
<li>无符号整数使用了<code>rs1</code>域进行了编码</li>
<li><code>CSRRW</code>指令在<code>CSR</code>和整数寄存器之间做原子交换，从CSR中读取源寄存器，并做零扩展，写回到<code>rd</code>，并且<code>rs1</code>中的值被写入了CSR。注意，如果<code>rd</code>为<code>x0</code>，则指令不应该读<code>CSR</code>寄存器，但是会写入CSR寄存器，不应该造成任何的副作用。</li>
<li><code>CSRRS</code>指令读<code>CSR</code>寄存器的值，并做零扩展，写回到<code>rd</code>，并且<code>rs1</code>被作为位掩码，其位1的对应位在CSR中也会被设置为1.</li>
<li><code>CSRRC</code>的作用和<code>CSRRS</code>相反，对应位1的位会被清除</li>
<li><strong>如果上述2个指令的源寄存器是x0，那么什么都不会做</strong></li>
<li>对于CSR的读写，在RISC-V中，定义是不会对后续指令的执行产生相应的影响的</li>
<li>某些CSR，例如：<code>instret</code>指令，有可能会因为指令被执行而更改。在这种情况下，如果CSR指令读了CSR，他应该读出指令执行之前的值，如果CSR指令写了CSR，那么应该覆盖原来的值。特别地，如果某个指令写了<code>instret</code>，那么这条指令后续的指令读出的应当是其写入的那个值。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hubohan.space/2020/08/24/Chisel_Note_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡博涵">
      <meta itemprop="description" content="CS Undergraduate at Harbin Institute of Technology, Shenzhen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hu's Blog">
    </span>

    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/Chisel_Note_7/" class="post-title-link" itemprop="url">Chisel学习笔记（七）：硬件生成器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-24 14:00:00" itemprop="dateCreated datePublished" datetime="2020-08-24T14:00:00+08:00">2020-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 11:08:44" itemprop="dateModified" datetime="2020-12-07T11:08:44+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Chisel的一大优势，就是不仅可以编写硬件描述代码，还可以灵活地编写硬件生成器，即“生成硬件”的代码。再其他硬件描述语言，例如Verilog中 ，笔者比较经常使用Python来生成一些繁复的代码，例如端口连线、实例化等。</p>
<h2 id="硬件模块参数化"><a href="#硬件模块参数化" class="headerlink" title="硬件模块参数化"></a>硬件模块参数化</h2><p>参数可以是非常普通的Scala整形常量，也可以是Chisel的硬件类型。</p>
<h3 id="简单的参数"><a href="#简单的参数" class="headerlink" title="简单的参数"></a>简单的参数</h3><ul>
<li><p>对电路定制最简单的参数化方法是使用参数来定义位宽。</p>
</li>
<li><p>参数可以作为Chisel模块的构造器参数传入类的构造函数中。</p>
</li>
</ul>
<p>下面是一个可定制宽度的加法器的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamAdder</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> a = <span class="type">Input</span>(<span class="type">UInt</span>(n.<span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> b = <span class="type">Input</span>(<span class="type">UInt</span>(n.<span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> c = <span class="type">Output</span>(<span class="type">UInt</span>(n.<span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    io.c := io.a + io.b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> add_8 = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">ParamAdder</span>(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<p>为了保证鲁棒性，防止硬件和预期不同，一般需要在类的头部加上一个<code>require</code>语句，来对参数的合法性进行断言。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParameterizedWidthAdder</span>(<span class="params">in0Width: <span class="type">Int</span>, in1Width: <span class="type">Int</span>, sumWidth: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  require(in0Width &gt;= <span class="number">0</span>)</span><br><span class="line">  require(in1Width &gt;= <span class="number">0</span>)</span><br><span class="line">  require(sumWidth &gt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in0 = <span class="type">Input</span>(<span class="type">UInt</span>(in0Width.<span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> in1 = <span class="type">Input</span>(<span class="type">UInt</span>(in1Width.<span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> sum = <span class="type">Output</span>(<span class="type">UInt</span>(sumWidth.<span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// a +&amp; b includes the carry, a + b does not</span></span><br><span class="line">  io.sum := io.in0 +&amp; io.in1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将硬件的行为参数化"><a href="#将硬件的行为参数化" class="headerlink" title="将硬件的行为参数化"></a>将硬件的行为参数化</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort4</span>(<span class="params">ascending: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in0 = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> in1 = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> in2 = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> in3 = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out0 = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out1 = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out2 = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out3 = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// this comparison funtion decides &lt; or &gt; based on the module&#x27;s parameterization</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">comp</span></span>(l: <span class="type">UInt</span>, r: <span class="type">UInt</span>): <span class="type">Bool</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span> (ascending) &#123;</span><br><span class="line">        l &lt; r</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l &gt; r</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> row10 = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> row11 = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> row12 = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> row13 = <span class="type">Wire</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line"></span><br><span class="line">  when(comp(io.in0, io.in1)) &#123;</span><br><span class="line">    row10 := io.in0            <span class="comment">// preserve first two elements</span></span><br><span class="line">    row11 := io.in1</span><br><span class="line">  &#125;.otherwise &#123;</span><br><span class="line">    row10 := io.in1            <span class="comment">// swap first two elements</span></span><br><span class="line">    row11 := io.in0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们看到，硬件的行为被参数化了，<code>comp(UInt, UInt) =&gt; Bool</code>函数接收的是两个硬件的节点，返回的也是两个硬件的节点。</p>
<h3 id="以类型为参数的函数"><a href="#以类型为参数的函数" class="headerlink" title="以类型为参数的函数"></a>以类型为参数的函数</h3><p>类型同样可以作为参数，传递入函数中。</p>
<p>以下的例子可以让Chisel生成对应数据类型的多路选择器。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMux</span></span>[ <span class="type">T</span> &lt;: <span class="type">Data</span>](sel: <span class="type">Bool</span>, tPath: <span class="type">T</span>, fPath: <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> ret = <span class="type">WireDefault</span>(fPath) </span><br><span class="line">    when(sel) &#123;</span><br><span class="line">        ret := tPath</span><br><span class="line">    &#125;</span><br><span class="line">    ret                <span class="comment">// 返回一个“硬件”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的例子中，表达式中<code>[T &lt;: Data]</code>定义了一个类型参数<code>T</code>，其中<code>T</code>应当是<code>Data</code>类或者<code>Data</code>的子类。<code>Data</code>是Chisel类型系统的根类型。</p>
<p>我们可以通过以下的方式获得一个多路选择器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> resA = myMux(selA, <span class="number">5.</span><span class="type">U</span>, <span class="number">10.</span><span class="type">U</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用不同类型的参数，将会造成runtime error.</p>
<p>我们甚至可以传入一个复杂的Bundle作为多路选择器的选择值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tVal = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">ComplexIO</span>)</span><br><span class="line"><span class="keyword">val</span> fVal = <span class="type">Wire</span>(<span class="keyword">new</span> <span class="type">ComplexIO</span>)</span><br><span class="line"><span class="keyword">val</span> resB = myMux(selB, tVal, fVal)</span><br></pre></td></tr></table></figure>

<p>我们可以使用cloneType方法来获取某个数据的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def myMux[ T &lt;: Data](sel: Bool, tPath: T, fPath: T): T &#x3D; &#123;</span><br><span class="line">    val ret &#x3D; Wire(fPath.cloneType)        &#x2F;&#x2F; 获取数据类型</span><br><span class="line">    ret :&#x3D; fPath</span><br><span class="line">    when(sel) &#123;</span><br><span class="line">        ret :&#x3D; tPath</span><br><span class="line">    &#125;</span><br><span class="line">    ret                &#x2F;&#x2F; 返回一个“硬件”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="以类型为模块的参数"><a href="#以类型为模块的参数" class="headerlink" title="以类型为模块的参数"></a>以类型为模块的参数</h3><p>设想，我们要实现一个NOC中在不同处理器核之间移动数据的模块，我们并不会在路由接口中对其进行硬编码，而是将其参数化。除此之外，我们还将路由端口的数量进行了参数化。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoCRouter</span>[ <span class="type">T</span> &lt;: <span class="type">Data</span>](<span class="params">dt: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inPort = <span class="type">Input</span>(<span class="type">Vec</span>(n, dt))</span><br><span class="line">        <span class="keyword">val</span> address = <span class="type">Input</span>(<span class="type">Vec</span>(n, <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">        <span class="keyword">val</span> outPort = <span class="type">Output</span>(<span class="type">Vec</span>(n, dt))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 根据地址进行路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在不同的处理器之间传递的信息，我们使用一个<code>Payload</code>来代表。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payload</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> data = <span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>)</span><br><span class="line">    <span class="keyword">val</span> flag = <span class="type">Bool</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以根据此来创建一个新的路由模块了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> router = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">NocRouter</span>(<span class="keyword">new</span> <span class="type">Payload</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h3 id="可参数化的Bundle"><a href="#可参数化的Bundle" class="headerlink" title="可参数化的Bundle"></a>可参数化的Bundle</h3><p>在上面的例子中，我们对于Payload使用了统一的Data类型Bool，进一步思考，是否可以将Data类型也进行参数化呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Port</span>[ <span class="type">T</span> &lt;: <span class="type">Data</span> ](<span class="params">dt: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> address = <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)</span><br><span class="line">    <span class="keyword">val</span> data = dt.cloneType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的<code>cloneType</code>方法，<code>Bundle</code>的参数<code>T</code>，应当是属于Chisel的<code>Data</code>类型的子类。在Bundle中，我们定义了一个<code>data</code>域，通过在参数上面应用<code>cloneType</code>方法，来定义数据类型。</p>
<blockquote>
<p>以下语句摘录自Chisel-Book，用于备忘：</p>
<p>However, when we use a constructor parameter, this parameter becomes a public field of the class. When Chisel needs to clone the type of the Bundle, e.g., when it is used in a Vec, this public field is in the way.</p>
</blockquote>
<p>为了避免上述情况，可以使用以下的方法定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Port</span>[ <span class="type">T</span> &lt;: <span class="type">Data</span> ](<span class="params">dt: <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> address = <span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>)</span><br><span class="line">    <span class="keyword">val</span> data = dt.cloneType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，我们可以定义路由模块了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NocRouter2</span>[ <span class="type">T</span> &lt;: <span class="type">Data</span> ](<span class="params">dt: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> inPort = <span class="type">Input</span>(<span class="type">Vec</span>(n, dt))</span><br><span class="line">        <span class="keyword">val</span> outPort = <span class="type">Output</span>(<span class="type">Vec</span>(n, dt))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> router = <span class="type">Module</span>(<span class="keyword">new</span> <span class="type">NocRouter2</span>(<span class="keyword">new</span> <span class="type">Port</span>(<span class="keyword">new</span> <span class="type">Payload</span>), <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h3 id="可选的IO端口"><a href="#可选的IO端口" class="headerlink" title="可选的IO端口"></a>可选的IO端口</h3><p>常用于有时可以选择去除某些调试信号。</p>
<p>注意到如果val是None，那么就没有这个信号了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HalfFullAdder</span>(<span class="params">val hasCarry: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">1.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> b = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">1.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> carryIn = <span class="keyword">if</span> (hasCarry) <span class="type">Some</span>(<span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">1.</span><span class="type">W</span>))) <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">    <span class="keyword">val</span> s = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">1.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> carryOut = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">1.</span><span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">val</span> sum = io.a +&amp; io.b +&amp; io.carryIn.getOrElse(<span class="number">0.</span><span class="type">U</span>)</span><br><span class="line">  io.s := sum(<span class="number">0</span>)</span><br><span class="line">  io.carryOut := sum(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选的参数"><a href="#可选的参数" class="headerlink" title="可选的参数"></a>可选的参数</h3><p>可以使用<code>Option</code>类型，来定义某个可选的参数，在实例化的时候，如果不提供这个参数，那么这个参数的<code>isDefined</code>字段就为<code>False</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayBy1</span>(<span class="params">resetValue: <span class="type">Option</span>[<span class="type">UInt</span>] = <span class="type">None</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> in  = <span class="type">Input</span>( <span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> reg = <span class="keyword">if</span> (resetValue.isDefined) &#123; <span class="comment">// resetValue = Some(number)</span></span><br><span class="line">        <span class="type">RegInit</span>(resetValue.get)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//resetValue = None</span></span><br><span class="line">        <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    reg := io.in</span><br><span class="line">    io.out := reg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(getVerilog(<span class="keyword">new</span> <span class="type">DelayBy1</span>))</span><br><span class="line">println(getVerilog(<span class="keyword">new</span> <span class="type">DelayBy1</span>(<span class="type">Some</span>(<span class="number">3.</span><span class="type">U</span>))))</span><br></pre></td></tr></table></figure>



<h2 id="用代码生成组合逻辑"><a href="#用代码生成组合逻辑" class="headerlink" title="用代码生成组合逻辑"></a>用代码生成组合逻辑</h2><p>在Chisel中，我们可以通过从Scala的<code>Array</code>转为Chisel的<code>Vec</code>类型，非常方便地创建组合逻辑表格。我们可以使用存储在文件中的数据，在硬件生成阶段创建一个逻辑表：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chisel3._</span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> address = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">        <span class="keyword">val</span> data = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> array = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">val</span> idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将文件的内容读入到scala的数组中</span></span><br><span class="line">    <span class="keyword">val</span> source = <span class="type">Source</span>.fromFile(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>(line &lt;- source.getLines()) &#123;</span><br><span class="line">        array(idx) = line.toInt</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将scala整数array转换成chisel的vec类型</span></span><br><span class="line">    <span class="keyword">val</span> table = <span class="type">VecInit</span>(array.map(_.<span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br><span class="line">    <span class="comment">// 使用索引访问Table</span></span><br><span class="line">    io.data := table(io.address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们把目光聚焦到这一行代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> table = <span class="type">VecInit</span>(array.map(_.<span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>)))</span><br></pre></td></tr></table></figure>

<p>一个Scala的数组（Array）可以被隐式地转换成一个序列（Sequence），序列支持<code>map</code>函数。<code>map</code>函数的意义是，将函数应用到序列中的每一个对象，并返回经过处理后的序列。在上述代码中，<code>_.U(8.W)</code>是一个匿名函数，<code>_</code>是一个通配符，代表列表中的元素，这个函数将列表中的Scala Int类型转换为Chisel中硬件的<code>UInt</code>，位宽为8. </p>
<p>有了这个方法，我们可以非常便捷的编码某些查找表逻辑，例如，二进制转BCD逻辑，等等。</p>
<h2 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h2><p>Chisel基于Scala，而Scala是一门面向对象的语言。因此，我们可以充分利用面向对象的特性，抽象出不同的硬件模块的共同行为，构造出一个父类。</p>
<p>在之前的学习中，我们已经构造了不同的计数器。假设现在有了新的场景，我们需要实现不同版本的计数器，来比较其资源消耗情况。</p>
<p>此时，我们需要先定义一个抽象类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticker</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span>&#123;</span><br><span class="line">        <span class="keyword">val</span> tick = <span class="type">Output</span>(<span class="type">Bool</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要具体的实现某个Ticker，则需要继承这个抽象类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpTicker</span> (<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ticker</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="type">N</span> = (n<span class="number">-1</span>).<span class="type">U</span></span><br><span class="line">    <span class="keyword">val</span> cntReg = <span class="type">RegInit</span> (<span class="number">0.</span><span class="type">U</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">    cntReg := cntReg + <span class="number">1.</span><span class="type">U</span></span><br><span class="line">    when(cntReg === <span class="type">N</span>) &#123;</span><br><span class="line">        cntReg := <span class="number">0.</span><span class="type">U</span></span><br><span class="line">    &#125;</span><br><span class="line">    io.tick := cntReg === <span class="type">N</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码的参数包括：</p>
<p>（1）类型：仅接收Ticker类型</p>
<p>（2）DUT：用以测试的代码</p>
<p>（3）期待得到tick的周期数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chisel3.iotesters.<span class="type">PeekPokeTester</span></span><br><span class="line"><span class="keyword">import</span> org.scalatest._</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TickerTester</span>[ <span class="type">T</span> &lt;: <span class="type">Ticker</span> ](<span class="params"> dut: <span class="type">T</span>, n: <span class="type">Int</span></span>) <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">PeekPokeTester</span>(<span class="params">dut: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// -1 is the notion that we have not yet seen the first tick</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">0</span> to n * <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            expect(dut.io.tick , <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            expect(dut.io.tick , <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> t = peek(dut.io.tick)</span><br><span class="line">        <span class="comment">// On a tick we reset the tester counter to N-1,</span></span><br><span class="line">        <span class="comment">// otherwise we decrement the tester counter</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            count = n<span class="number">-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">           step (<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配机制"><a href="#模式匹配机制" class="headerlink" title="模式匹配机制"></a>模式匹配机制</h2><p>Scala的模式匹配机制在Chisel中非常常见，Scala提供了强大的模式匹配机制，包括：</p>
<ul>
<li>类似于C语言的<code>switch</code>语句的匹配功能</li>
<li>对于不同值的任意组合进行匹配</li>
<li>对于变量的类型进行匹配，这一点非常好用，例如：<ul>
<li>用于迭代的值来自于列表，而列表中对象的类型不尽相同</li>
<li>变量是某个超类的成员，但并不知道其子类是什么</li>
</ul>
</li>
<li>通过正则表达式匹配字符串的子串</li>
</ul>
<h3 id="值匹配"><a href="#值匹配" class="headerlink" title="值匹配"></a>值匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y is an integer variable defined somewhere else in the code</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">7</span></span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line"><span class="keyword">val</span> x = y <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="string">&quot;zero&quot;</span> <span class="comment">// 可以写在同一行里</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt;        <span class="comment">// 可以不写在同一行里</span></span><br><span class="line">      <span class="string">&quot;one&quot;</span>        <span class="comment">// 在下一个case之前都是这个case的代码</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; &#123;      <span class="comment">// 可以添加大括号，但通常不是必要的</span></span><br><span class="line">      <span class="string">&quot;two&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">&quot;many&quot;</span> <span class="comment">// _可以匹配所有的值</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;y is &quot;</span> + x)</span><br></pre></td></tr></table></figure>

<ul>
<li>模式匹配是按照从上到下的顺序的，一旦发生成功匹配，就不会进行接下来的搜索</li>
<li>通配符<code>_</code>的作用是匹配其他值，用于处理没有匹配上的情况</li>
</ul>
<h3 id="多值匹配"><a href="#多值匹配" class="headerlink" title="多值匹配"></a>多值匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animalType</span></span>(biggerThanBreadBox: <span class="type">Boolean</span>, meanAsCanBe: <span class="type">Boolean</span>): <span class="type">String</span> = &#123;</span><br><span class="line">  (biggerThanBreadBox, meanAsCanBe) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">true</span>, <span class="literal">true</span>) =&gt; <span class="string">&quot;wolverine&quot;</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">true</span>, <span class="literal">false</span>) =&gt; <span class="string">&quot;elephant&quot;</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">false</span>, <span class="literal">true</span>) =&gt; <span class="string">&quot;shrew&quot;</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="literal">false</span>, <span class="literal">false</span>) =&gt; <span class="string">&quot;puppy&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">println(animalType(<span class="literal">true</span>, <span class="literal">true</span>))</span><br></pre></td></tr></table></figure>

<p>多值匹配的语法如上所示。</p>
<h3 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sequence = <span class="type">Seq</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">0.0</span>)</span><br><span class="line">sequence.foreach &#123; x =&gt;</span><br><span class="line">  x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; println(<span class="string">s&quot;<span class="subst">$x</span> is a String&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">Int</span>    =&gt; println(<span class="string">s&quot;<span class="subst">$x</span> is an Int&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">Double</span> =&gt; println(<span class="string">s&quot;<span class="subst">$x</span> is a Double&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">s&quot;<span class="subst">$x</span> is an unknown type!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala是强类型语言，类型匹配是一种强大的机制。</p>
<p>如果想匹配多种类型，可以这样写，注意此时需要使用通配符<code>_</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sequence = <span class="type">Seq</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">0.0</span>)</span><br><span class="line">sequence.foreach &#123; x =&gt;</span><br><span class="line">  x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _: <span class="type">Int</span> | _: <span class="type">Double</span> =&gt; println(<span class="string">s&quot;<span class="subst">$x</span> is a number!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">s&quot;<span class="subst">$x</span> is an unknown type!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayBy1</span>(<span class="params">resetValue: <span class="type">Option</span>[<span class="type">UInt</span>] = <span class="type">None</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in  = <span class="type">Input</span>( <span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">val</span> reg = resetValue <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(r) =&gt; <span class="type">RegInit</span>(r)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span>    =&gt; <span class="type">Reg</span>(<span class="type">UInt</span>())</span><br><span class="line">  &#125;</span><br><span class="line">  reg := io.in</span><br><span class="line">  io.out := reg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用模式匹配去匹配类型。</p>
<h2 id="隐式"><a href="#隐式" class="headerlink" title="隐式"></a>隐式</h2><p>Scala引入了隐式的概念，允许编译器引入部分语法糖。</p>
<h3 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h3><p>有时，我们的代码可能需要访问一些顶层的变量，特别是在比较深的嵌套函数调用中。相比于我们手动将这些变量在每次函数调用中传递，我们可以使用隐式参数。</p>
<p>在Scala中，我们可以隐式或显式地传入参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CatDog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> numberOfCats: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line">  <span class="comment">//implicit val numberOfDogs: Int = 5</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tooManyCats</span></span>(nDogs: <span class="type">Int</span>)(<span class="keyword">implicit</span> nCats: <span class="type">Int</span>): <span class="type">Boolean</span> = nCats &gt; nDogs</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">val</span> imp = tooManyCats(<span class="number">2</span>)    <span class="comment">// 隐式地传入了参数nCats </span></span><br><span class="line">  <span class="keyword">val</span> exp = tooManyCats(<span class="number">2</span>)(<span class="number">1</span>) <span class="comment">// 显式地传入了参数nCats </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CatDog</span>.imp</span><br><span class="line"><span class="type">CatDog</span>.exp</span><br></pre></td></tr></table></figure>

<p>此处，我们首先定义了一个<strong>隐式值</strong><code>numberOfCats</code>。在某个定义域内，<strong>同一个类型</strong>的隐式值只能有一个值。（Scala通过类型来进行判定的，从上述代码可以看到，<code>nCats</code>和<code>numberOfCats</code>并不同名）</p>
<p>然后，我们定义了一个函数，接收两个参数列表，第一个是显式的参数值，第二个是隐式的参数值。</p>
<p>当我们调用<code>tooManyCats</code>函数的时候，我们可以隐藏第二个参数列表（让编译器为我们寻找隐式值），或是显式地提供相应的参数（可以和默认的隐式值不同）。</p>
<p>以下情况下，隐式参数推断会失败：</p>
<ul>
<li><p>在作用域中定义了给定类型的两个或多个隐含值</p>
</li>
<li><p>编译器找不到函数调用所需的隐含值</p>
</li>
</ul>
<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>类似于隐式参数的，隐式转换常常被用于减少模板代码的数量。更具体地，它们用来<strong>自动将Scala对象转换为其他对象</strong>。</p>
<p>在下面的例子中，我们有两个类，分别为<code>Animal</code>和<code>Human</code>类，<code>Animal</code>有<code>Species</code>字段，但是<code>Human</code>没有。</p>
<p>当我们在<code>Human</code>上面调用<code>Species</code>时，编译器会尝试进行隐式转换。</p>
<p>因此，为了完成<code>Animal</code>到<code>Human</code>之间的转换，我们需要定义一个转换函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">val name: <span class="type">String</span>, val species: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Human</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">implicit</span> <span class="title">def</span> <span class="title">human2animal</span>(<span class="params">h: <span class="type">Human</span></span>)</span>: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Animal</span>(h.name, <span class="string">&quot;Homo sapiens&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> me = <span class="keyword">new</span> <span class="type">Human</span>(<span class="string">&quot;Adam&quot;</span>)</span><br><span class="line">println(me.species)</span><br></pre></td></tr></table></figure>

<h2 id="例子：Mealy机生成器"><a href="#例子：Mealy机生成器" class="headerlink" title="例子：Mealy机生成器"></a>例子：Mealy机生成器</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mealy machine has</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryMealyParams</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">  // number of states</span></span></span><br><span class="line"><span class="class"><span class="params">  nStates: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">  // initial state</span></span></span><br><span class="line"><span class="class"><span class="params">  s0: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">  // function describing state transition</span></span></span><br><span class="line"><span class="class"><span class="params">  stateTransition: (<span class="type">Int</span>, <span class="type">Boolean</span></span>) <span class="title">=&gt;</span> <span class="title">Int</span>,</span></span><br><span class="line"><span class="class">  <span class="title">//</span> <span class="title">function</span> <span class="title">describing</span> <span class="title">output</span></span></span><br><span class="line"><span class="class">  <span class="title">output</span></span>: (<span class="type">Int</span>, <span class="type">Boolean</span>) =&gt; <span class="type">Int</span></span><br><span class="line">) &#123;</span><br><span class="line">  require(nStates &gt;= <span class="number">0</span>)</span><br><span class="line">  require(s0 &lt; nStates &amp;&amp; s0 &gt;= <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryMealy</span>(<span class="params">val mp: <span class="type">BinaryMealyParams</span></span>) <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">    <span class="keyword">val</span> out = <span class="type">Output</span>(<span class="type">UInt</span>())</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> state = <span class="type">RegInit</span>(<span class="type">UInt</span>(), mp.s0.<span class="type">U</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// output zero if no states</span></span><br><span class="line">  io.out := <span class="number">0.</span><span class="type">U</span></span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until mp.nStates) &#123;</span><br><span class="line">    when (state === i.<span class="type">U</span>) &#123;</span><br><span class="line">      when (io.in) &#123;</span><br><span class="line">        state  := mp.stateTransition(i, <span class="literal">true</span>).<span class="type">U</span></span><br><span class="line">        io.out := mp.output(i, <span class="literal">true</span>).<span class="type">U</span></span><br><span class="line">      &#125;.otherwise &#123;</span><br><span class="line">        state  := mp.stateTransition(i, <span class="literal">false</span>).<span class="type">U</span></span><br><span class="line">        io.out := mp.output(i, <span class="literal">false</span>).<span class="type">U</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码是一个Mealy状态机的生成逻辑。首先，声明了一个<code>case class</code>，在里面包装了所有构建Mealy机所需的参数，包括状态的数量、初态、状态转移函数和输出函数，并且使用了两个<code>require</code>语句做断言，保证状态的合法性。</p>
<p><code>BinaryMealy</code>是状态机的硬件模块，其构造器接收参数<code>mp</code>，这个参数用以构建状态机。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Bohan-Hu/img/images/image-20200824210948423.png" alt="image-20200824210948423"></p>
<p>下面构造这个状态机的参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nStates = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> s0 = <span class="number">2</span></span><br><span class="line"><span class="comment">// 将上述函数翻译成状态转移函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stateTransition</span></span>(state: <span class="type">Int</span>, in: <span class="type">Boolean</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(in) &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态机输出函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output</span></span>(state:<span class="type">Int</span>, in: <span class="type">Boolean</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((state == <span class="number">1</span> &amp;&amp; !in) || (state == <span class="number">0</span> &amp;&amp; in)) &#123;</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> testParams = <span class="type">BinaryMealyParams</span>(nStates, s0, stateTransition, output)</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胡博涵</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

</body>
</html>
